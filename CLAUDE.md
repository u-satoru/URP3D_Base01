# CLAUDE.md

 **じっくり考える**  

これは **Unity 6で作成された3Dゲームプロジェクトのベーステンプレート** です。 Universal Render Pipeline (URP) を使用しています。

## 概要

このプロジェクトは、イベント駆動型アーキテクチャとコマンドパターンを組み合わせた、拡張性の高い3Dゲームの基盤を提供します。Scriptable Objectを活用し、データとロジックの分離を促進することで、効率的な開発とメンテナンスを目的としています。

## 制作想定ゲーム

- **シングルプレイゲーム**
- ステルスアクションゲーム
- 3Dプラットフォーマー
- アドベンチャーゲーム
- ストラテジーゲーム
- TPS/FPSゲーム(一人称視点/三人称視点)

## 対応プラットフォーム
- iOS
- Android
- Windows

## 主な機能

- **イベント駆動型アーキテクチャ**: `GameEvent` を介したコンポーネント間の疎結合な連携。
- **コマンドパターン**: ゲーム内のアクション（例：ダメージ、回復）をオブジェクトとしてカプセル化し、再利用と管理を容易にします。
- **ObjectPool最適化**: 頻繁に作成・破棄されるコマンドオブジェクトをプール化し、メモリ効率とパフォーマンスを大幅に向上させます（95%のメモリ削減効果）。
- **Scriptable Objectベースのデータ管理**: キャラクターのステータスやアイテム情報などをアセットとして管理。
- **ステルスゲーム用サウンドシステム**: 3D空間オーディオ、NPCの聴覚センサー、動的環境サウンド、オーディオマスキング機能を含む包括的な音響システム。
- **基本的なプレイヤー機能**: 移動やインタラクションの基盤。
- **エディタ拡張**: コマンドの発行やイベントの流れを視覚化するカスタムウィンドウ。

## アーキテクチャとデザインパターン

このプロジェクトでは、主に以下のアーキテクチャとデザインパターンが採用されています。

1.  **イベント駆動型アーキテクチャ (Event-Driven Architecture)**:
    *   コンポーネント間の結合を疎にするため、`ScriptableObject` をベースにしたイベントチャネル（`GameEvent`）を使用しています。
    *   これにより、あるオブジェクトが別のオブジェクトを直接参照することなく、イベントの発行と購読を通じて通信できます。例えば、プレイヤーがダメージを受けたとき、「PlayerDamaged」イベントが発行され、UIやサウンドシステムがそれをリッスンして各自の処理を行います。

2.  **コマンドパターン (Command Pattern)**:
    *   ゲーム内で行われる操作（例: 攻撃、回復、アイテム使用）を「コマンド」というオブジェクトとしてカプセル化しています。
    *   これにより、操作の実行、取り消し（Undo）、再実行（Redo）、遅延実行、キューイングなどが容易になります。`ICommand` インターフェースとそれを実装した具体的なコマンドクラス（`DamageCommand`, `HealCommand`など）がこれにあたります。

3.  **ObjectPool最適化パターン (Object Pool Pattern)**:
    *   頻繁に作成・破棄されるコマンドオブジェクトを事前作成したプールから再利用することで、メモリ確保コストとガベージコレクションを大幅に削減します。
    *   `CommandPool`が中央管理し、`IResettableCommand`インターフェースによって状態リセット可能なコマンドの安全な再利用を実現します。測定結果では95%のメモリ使用量削減と67%の実行速度改善を達成しています。

4.  **ScriptableObjectベースのデータ駆動設計**:
    *   キャラクターのステータス、アイテムのスペック、イベント定義など、多くのゲームデータを `ScriptableObject` として作成し、アセットとして管理しています。
    *   これにより、プログラマー以外のチームメンバー（ゲームデザイナーなど）も、コードを触ることなくゲームのバランス調整やデータ編集が可能になります。

5.  **State パターン**:
    *   キャラクターの状態（待機、歩行、攻撃中など）を個別のクラスとして管理するために使用が推奨されています。（`StatePattern_Migration_Guide.md`より）

6.  **Strategy パターン**:
    *   アルゴリズムのファミリーを定義し、それぞれをカプセル化して相互に置き換え可能にするために使用されます。これにより、アルゴリズムの変更が容易になり、クライアントコードは具体的なアルゴリズムに依存しなくなります。

7.  **Factory+Registry パターン**:
    *   オブジェクトの生成を担当するファクトリーと、生成されたオブジェクトを管理するレジストリを組み合わせることで、柔軟で拡張性のあるシステムを構築します。これにより、新しいオブジェクトタイプの追加が容易になり、依存関係の管理が改善されます。

8.  **Lifecycle Management パターン**:
    *   オブジェクトのライフサイクル（生成、使用、破棄）を管理するためのパターンです。これにより、リソースの効率的な使用とメモリリークの防止が可能になります。

9.  **Service Locator + Event駆動のハイブリッドアプローチ**:
    *   サービスロケーターを使用して、アプリケーション全体で共有されるサービス（例：オーディオマネージャー、ゲームマネージャーなど）へのアクセスを提供します。
    *   これにより、依存関係の注入が不要になり、コードの可読性と保守性が向上します。イベント駆動型アーキテクチャと組み合わせることで、サービス間の疎結合な通信も実現しています。
    *   またこれらのパターンを組み合わせることで、関心事の分離が促進され、拡張性、再利用性、メンテナンス性の高い構造を目指しています。

## 技術仕様

- **Unity Version**: `6000.0.42f1`
- **Render Pipeline**: Universal Render Pipeline (URP)
- **Scripting Backend**: Mono
- **API Compatibility Level**: .NET Standard 2.1

## アーキテクチャ制約

- **Dependency Injection (DI) フレームワークは使用しない**。

## ディレクトリ構成

-   `Assets/_Project/Core`: ゲームのコアロジック（イベント、コマンド、オーディオシステム、データ構造など）。**コアロジックは必ずこのディレクトリに配置してください**。
-   `Assets/_Project/Features`: 各機能（プレイヤー、AI、カメラなど）の実装。**新しい機能はここに追加してください**。 **機能コードはCoreに混在させないでください**。
-   `Assets/_Project/Tests`: ユニットテストとプレイモードテスト。 **テストコードは必ずここに配置してください**。 **テストコードはCoreやFeaturesに混在させないでください**。
-   `Assets/_Project/Scenes`: ゲームシーン。
-   `Assets/_Project/Docs`: プロジェクト関連のドキュメント（ステルスオーディオシステム仕様書、SDD実践ガイドを含む）。
-   `Assets/_Project/Works`: 作業ログ保管庫（日時フォルダ（YYYYMMDD_HHMM）で、各ファイルのスナップショットを保管します）。
-   `Assets/_Project/Docs`: プロジェクト関連のドキュメント。 **ドキュメントは必ずここに配置してください**。
-   `Assets/_Project/Tests`: テスト関連のファイル。 **テストコードは必ずここに配置してください**。 **テストコードはCoreやFeaturesに混在させないでください**。
-   `Assets/_Project/Logs` : ログファイル。
-   `Assets/_Project/ThirdParty`: サードパーティ製アセットのラッピング。
-   `Assets/Plugins`: サードパーティ製アセット。 **直接編集しないでください**。
-   `Assets/_Project/Docs/Works/` - 作業ログ保管庫（日時フォルダ（YYYYMMDD_HHMM）で、`SPEC.md`、`REQUIREMENTS.md`、`DESIGN.md`、`TASKS.md`、`TODO.md`など、各ファイルのスナップショットを保管します）。

## スペック駆動開発（SDD）の実践

このプロジェクトでは、AIツールと連携したスペック駆動開発（SDD）を推奨しています。SDDは人間の意図を段階的に機械実行可能な命令に変換するパイプラインとして機能します。

### SDD Markdownファイル構成

#### プロジェクトルート配置（基盤仕様書）
- `SPEC.md` - 初期構想・要件定義（人間作成）
- `REQUIREMENTS.md` - 形式化された要件（AI生成）
- `DESIGN.md` - 技術設計書（AI生成）
- `TASKS.md` - 実装タスク一覧（AI生成）
- `TODO.md` - 進行中タスク管理（人間作成）


#### 作業ディレクトリ配置（実装管理）
- `Assets/_Project/Docs/Works/` - 作業ログ保管庫（日時フォルダ（YYYYMMDD_HHMM）で、`SPEC.md`、`REQUIREMENTS.md`、`DESIGN.md`、`TASKS.md`、`TODO.md`など、各ファイルのスナップショットを保管します）。

### SDD 5つのフェーズ
1. **構想**（SPEC.md） - 高レベルビジョンの定義
2. **形式化**（REQUIREMENTS.md） - 構造化された要件定義
3. **設計**（DESIGN.md） - 技術的実装戦略
4. **分解**（TASKS.md） - 実行可能なタスクリスト
5. **実装・検証** - AIによるコード生成と品質保証

### Claude Code連携
各フェーズでClaude Codeと効果的に連携し、以下のようなワークフローを実現：
- `/spec-create` - SPEC.mdからREQUIREMENTS.mdを生成
- `/design-create` - REQUIREMENTS.mdからDESIGN.mdを生成
- `/tasks-create` - DESIGN.mdからTASKS.mdを生成
- `/todo-execute` - TODO.mdの最高優先度タスクを実行
- `/create-test` - 実装コードからユニットテストを生成

詳細は [`Assets/_Project/Docs/SDD_Markdown作成実践ガイド.md`](Assets/_Project/Docs/SDD_Markdown作成実践ガイド.md) を参照してください。

## **MCPサーバー優先順位付けのための戦略的フレームワーク**

### **1. MCPサーバー機能と制御レベルの比較概要**

このセクションでは、第II部の分析を統合し、アーキテクトが一目で参照できる明確な要約表を提示します。

**表1.1: MCPサーバーの能力と優先順位付けマトリクス**

| サーバー | 主な役割 | データスコープ | 制御レベル | 主要ユースケース | 解決する主要課題 |
| :---- | :---- | :---- | :---- | :---- | :---- |
| ddg-serch | リアルタイムウェブ検索 | グローバルインターネット（非構造化） | **読み取り専用**（情報検索） | 一般知識の質問、最新情報の検索 | 知識のカットオフとリアルタイム性 |
| context7 | 技術文書検索 | 公開コードライブラリ（構造化） | **読み取り専用**（情報検索） | 正確で最新のコード記述、API利用のデバッグ | コードのハルシネーションとドキュメントの陳腐化 |
| deepwiki | コードベース分析 | 特定のGitリポジトリ（意味的） | **読み取り専用**（情報検索） | 新規プロジェクトへの参加、複雑なアーキテクチャの理解 | コードベースの理解とオンボーディングの摩擦 |
| git | バージョン管理 | ローカル/リモートリポジトリ | **読み書き**（状態変更） | コードコミットの自動化、ブランチ管理、パッチ適用 | 手動でのバージョン管理とコード統合 |
| blender-mcp | 3Dコンテンツ制作 | Blenderアプリケーションの状態 | **読み書き**（アプリケーション制御） | 自然言語からの3Dアセットのプロシージャル生成 | 3Dモデリングの高い技術的障壁 |
| unityMCP | ゲーム開発 | Unity Editorの状態 | **読み書き**（アプリケーション制御） | レベルデザインの自動化、ゲームアセット管理、テスト実行 | 反復的/手動のゲーム開発タスク |

この表は、エージェントのアーキテクトが直面する「特定のサブタスクに適したツールはどれか？」という複雑な決定を支援します。単なる機能リストではなく、複数の戦略的な軸に沿ってツールを比較する視点を提供します。「制御レベル」の列は、安全な読み取り専用サーバーと、強力だがリスクの高い読み書きサーバーを即座に区別します。「データスコープ」の列は、各サーバーが提供する情報の粒度を明確にします。「解決する主要課題」の列は、各サーバーの価値提案を特定のペインポイントの観点から捉えます。これにより、アーキテ...

### **2. MCPサーバ優先順位付けのカスケード：多層的な意思決定モデル**

これは、ユーザーの「 **しっかり考えて** 」優先度を教えてほしいという要求に答えるための中心的なフレームワークです。構造化されたトップダウンの意思決定プロセスを提示します。

#### **レイヤー1：タスクドメインの定義（エージェントの高レベルな目標は何か？）**

* **知識獲得:** 情報を学習または検索することが目標です。  
  * **人間の優先度:** ddg-serch, context7, deepwiki。  
  * **AIの優先度:** 1. ddg-serch (最新かつ広範な情報を得るため)、2. context7 (技術的な正確性を確保するため)、3. deepwiki (特定のコードベースを深く理解するため)。AIは通常、広い文脈から具体的な情報へと絞り込んでいきます。  
* **ソフトウェア開発:** コードの記述、修正、または管理が目標です。  
  * **人間の優先度:** git, context7, deepwiki。  
  * **AIの優先度:** 1. context7/deepwiki (変更を加える前に、正確な情報とコードベースの理解を深めるため)、2. git (計画に基づき、実際にコードを変更するため)。AIは行動を起こす前に、まず状況を完全に把握することを優先します。  
* **クリエイティブ制作:** デジタルアセット（3Dモデル、ゲームレベル）の作成が目標です。  
  * **人間の優先度:** blender-mcp, unityMCP。  
  * **AIの優先度:** blender-mcpまたはunityMCPがタスクの中心となります。AIは、与えられた指示を実行するために、これらのサーバーを直接的かつ継続的に使用します。  
  * **ユースケース別AI優先度（3Dゲーム制作）:**  
    1. **unityMCP (最高):** ゲームエンジン内での直接的な操作が最優先されます。AIはシーンの状態確認 (get_editor_state) とコマンド実行 (execute_editor_command) を繰り返し、アセットの配置、レベルデザイン、コンポーネントの調整などを自律的に行います 32。  
    2. **blender-mcp (高):** Unityにインポートするカスタム3Dモデルやアセットを制作するために使用されます。AIは自然言語の指示からプロシージャルにアセットを生成します 27。  
    3. **context7 (高):** UnityのAPI、C#スクリプティング、または特定のプラグインに関する正確な技術情報を取得するために不可欠です。これにより、AIが生成するコードの品質と正確性が保証されます 19。  
    4. **git (中):** 作成されたゲームアセット、シーンファイル、スクリプトのバージョン管理を行います。AIはタスクの節目で変更をコミットし、プロジェクトの整合性を保ちます 21。  
    5. **ddg-serch (低):** 新しいアセットストアの検索、特定のエラーに関するコミュニティの解決策の調査、または一般的なデザインのインスピレーションを得るために補助的に使用されます。

#### **レイヤー2：情報の具体性の判断（必要な知識の粒度はどの程度か？）**

* **グローバル＆リアルタイム:** 最新の出来事や一般的なトピック向け。  
  * **人間の優先度:** ddg-serch。  
  * **AIの優先度:** **最高。** タスクの初期段階で、AIはまずddg-serchを使い、現状の把握や一般的な情報収集を行います。これは、あらゆるタスクの出発点となります。  
* **公開＆技術的:** 特定の公開ライブラリやAPIの使用向け。  
  * **人間の優先度:** context7。  
  * **AIの優先度:** **高。** ddg-serchでの調査後、特にソフトウェア開発タスクにおいて、AIはcontext7を利用して信頼性の高い技術情報を取得し、ハルシネーションを避けます。  
* **プライベート＆アーキテクチャ的:** 特定のコードベースの内部動作の理解向け。  
  * **人間の優先度:** deepwiki。  
  * **AIの優先度:** **中〜高。** 特定のコードベースに対する変更や分析が求められる場合、AIはdeepwikiを優先的に使用し、コードの構造や依存関係を正確に理解しようとします。

#### **レイヤー3：制御の所在の評価（エージェントは読み取り（READ）または書き込み（WRITE）が必要か？）**

これは、セキュリティと能力に関する最も重要な区別です。

* **読み取り専用（情報収集）:** リスクが低く、コンテキストを提供するために使用されます。  
  * **人間の優先度:** ddg-serch, context7, deepwiki。これらは情報探索タスクのデフォルトとすべきです。  
  * **AIの優先度:** **常に最優先。** AIエージェントは、状態を変更するアクション（書き込み）を実行する前に、まず読み取り専用サーバーを使用して可能な限り多くの情報を収集し、状況を完全に理解しようとします。これは、安全で効果的なタスク遂行のための基本原則です。  
* **読み書き（状態変更）:** リスクが高く、明示的なユーザーの同意が必要です。アクションを実行するために使用されます。  
  * **人間の優先度:** git, blender-mcp, unityMCP。これらはエージェントの目標が明確に何かを変更することである場合にのみ有効にすべきです。  
  * **AIの優先度:** **計画後の段階で優先。** AIは、情報収集と分析に基づいて詳細な実行計画を立てた後、ユーザーの承認を得てから初めて書き込み操作を行います。自律的な意思決定による予期せぬ変更を避けるため、このステップは慎重に扱われます。

#### **レイヤー4：環境の複雑性の評価（エージェントは何と対話しているか？）**

* **テキスト/データ:** 単純な構造化または非構造化データ。  
  * **人間の優先度:** ddg-serch, context7, git。  
  * **AIの優先度:** **高。** これらのサーバーは基本的な情報収集とコード操作の基盤であり、多くのタスクで頻繁に使用されます。AIはこれらの比較的単純な対話を通じて、より複雑なタスクの準備をします。  
* **ステートフルなアプリケーション:** 独自の内部状態、UI、ロジックを持つ複雑なアプリケーション。  
  * **人間の優先度:** blender-mcp, unityMCP。これらのサーバーはより強力ですが、より複雑なプロンプトやエラーハンドリングが必要になる場合があります。  
  * **AIの優先度:** **タスク特化型で高。** クリエイティブ制作のような特定のタスクでは、これらのサーバーが中心的な役割を果たします。AIは、get_editor_stateのようなツールで現在の状態を頻繁に確認し、execute_editor_commandで少しずつ変更を加えるという、観察と行動のループを繰り返します 32。

#### **レイヤー5：セキュリティとガバナンスの態勢の考慮（「影響範囲」はどの程度か？）**

* **個人/開発者ワークフロー:** セキュリティ制約が低い。  
  * **人間の優先度:** ローカルのgitサーバーやblender-mcpは許容されます。  
  * **AIの優先度:** AIは環境の制約を認識しますが、この環境では幅広いツールを自由に利用してタスクの解決を試みます。ただし、それでもなお、破壊的な操作の前にはユーザーの確認を求めることが推奨される設計となります。

## 主要なパッケージ

-   `com.unity.render-pipelines.universal`: Universal Render Pipeline
-   `com.unity.inputsystem`: 新しい入力システム
-   `com.unity.cinemachine`: 高度なカメラ制御
-   `com.unity.ai.navigation`: ナビゲーションと経路探索
-   `com.unity.test-framework`: ユニットテストとプレイモードテスト

## サードパーティ製アセット/ライブラリ
-   `UniTask`: 非同期プログラミングライブラリ（[Cysharp](https://github.com/Cysharp/UniTask)）
-   `DOTween Pro`: 高度なアニメーションとタイムライン制御（[Demigiant](http://dotween.demigiant.com/)）
-   `Odin Inspector`: エディタ拡張とカスタムインスペクタ（[Sirenix](https://odininspector.com/)）
-   `Odin Serializer`: 高度なシリアライゼーション（[Sirenix](https://odininspector.com/)）
-   `Odin Validator`: データ検証ツール（[Sirenix](https://odininspector.com/)）

## **注意点**
- **テストケースを必ず作成**: 新しい機能や修正を加える際には、必ず対応するユニットテストとプレイモードテストを `Assets/_Project/Tests` に作成してください。これにより、コードの品質と安定性が維持されます。
- **サードパーティ製アセットの直接編集禁止**: `Assets/Plugins` フォルダ内のアセットは直接編集しないでください。必要な変更は、可能な限り拡張やラッピングを通じて行い、将来のアップデートでの互換性を保つようにしてください。  
- **コアロジックの分離**: ゲームのコアロジックは必ず `Assets/_Project/Core` に配置し、機能コードは `Assets/_Project/Features` に分離してください。これにより、コードベースの可読性と保守性が向上します。
- **テストコードの専用ディレクトリ**: ユニットテストとプレイモードテストは必ず `Assets/_Project/Tests` に配置し、CoreやFeaturesに混在させないでください。これにより、テストの管理と実行が容易になります。
- **ドキュメントの専用ディレクトリ**: プロジェクト関連のドキュメントは必ず `Assets/_Project/Docs` に配置してください。これにより、ドキュメントの一元管理が可能になります。
- **ソースコードファイル(.cs)とアセンブリ定義ファイル(.asmdef)の命名規則**: ソースコードファイルとアセンブリ定義ファイルは、PascalCase（例: `PlayerController.cs`, `GameEvents.asmdef`）を使用してください。これにより、コードベースの一貫性と可読性が向上します。
- **ソースコードファイル(.cs)とアセンブリ定義ファイル(.asmdef)とmetaファイルの一貫性確保**: ソースコードファイル、アセンブリ定義ファイル、metaファイルの名前は常に一致させてください。これにより、Unityエディタ内での参照の整合性が保たれ、ビルドエラーや参照エラーを防止します。
- **SDDドキュメントのバージョン管理**: SDD関連のMarkdownファイル（`SPEC.md`, `REQUIREMENTS.md`, `DESIGN.md`, `TASKS.md`, `TODO.md`）は、`Assets/_Project/Docs/Works/` フォルダ内の日時フォルダにスナップショットを保管し、変更履歴を明確に管理してください。これにより、プロジェクトの進行状況と意思決定の背景を追跡できます。

## **制約**
- **実行する前に、必ずコンパイルエラーを解消してください。** コンパイルエラーが存在する場合、Unityエディタの動作が不安定になる可能性があります。

## 名前空間規約

### 基本規則
- Root: `asterivo.Unity60`
- Core機能: `asterivo.Unity60.Core.*`
- 機能実装: `asterivo.Unity60.Features.*`
- テスト: `asterivo.Unity60.Tests.*`

### 禁止事項
- Core層からFeatures層への参照禁止
- _Project.* の新規使用禁止（段階的削除）

## **GitHub Actions設定**
- `Assets/_Project/.github/workflows/unity-ci.yml`: UnityプロジェクトのCI/CDパイプライン設定
  - **ビルドターゲット**: Windows, iOS, Android
  - **テスト実行**: ユニットテストとプレイモードテストの自動実行
  - **コード品質チェック**: コードスタイルと静的解析ツールの実行
  - **アセットの最適化**: 不要なアセットの検出と削除
  - **通知設定**: ビルドとテストの結果をSlackやメールで通知
- `Assets/_Project/.github/workflows/unity-release.yml`: リリースパイプライン設定
  - **バージョニング**: 自動的なバージョン番号の更新
  - **ビルドアーティファクトの生成**: 各プラットフォーム向けのビルド生成
  - **リリースノートの自動生成**: コミットメッセージからリリースノートを生成
  - **GitHubリリースの作成**: ビルドアーティファクトを添付してGitHubリリースを作成
  - **通知設定**: リリースの成功/失敗をSlackやメールで通知
- `Assets/_Project/.github/workflows/dependency-check.yml`: 依存関係の監視と更新
  - **依存関係のスキャン**: 定期的に依存関係をスキャンし、脆弱性を検出
  - **更新の提案**: 新しいバージョンが利用可能な場合、プルリクエストを自動生成
  - **通知設定**: 依存関係の更新状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/code-quality.yml`: コード品質の継続的監視
  - **静的解析ツールの実行**: 定期的にコードベースを解析し、コード品質を評価
  - **コードカバレッジの測定**: ユニットテストのカバレッジを測定し、レポートを生成
  - **通知設定**: コード品質の問題をSlackやメールで通知
- `Assets/_Project/.github/workflows/sdd-integration.yml`: SDDドキュメントの管理と連携
  - **ドキュメントのバージョン管理**: SDD関連のMarkdownファイルの変更を監視し、バージョン管理を強化
  - **AIツールとの連携**: SDDドキュメントの更新に基づき、AIツールとの連携を自動化
  - **通知設定**: SDDドキュメントの更新状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/asset-optimization.yml`: アセットの最適化と管理
  - **アセットの使用状況の監視**: プロジェクト内のアセット使用状況を定期的に監視
  - **不要なアセットの検出**: 使用されていないアセットを検出し、削除を提案
  - **通知設定**: アセットの最適化状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/security-audit.yml`: セキュリティ監査とコンプライアンス
  - **セキュリティスキャンの実行**: 定期的にコードベースと依存関係をスキャンし、セキュリティリスクを検出
  - **コンプライアンスチェック**: プロジェクトがセキュリティポリシーに準拠しているかを確認
  - **通知設定**: セキュリティ監査の結果をSlackやメールで通知
- `Assets/_Project/.github/workflows/performance-monitoring.yml`: パフォーマンス監視と最適化
  - **パフォーマンスベンチマークの実行**: 定期的にパフォーマンステストを実行し、パフォーマンスの変化を監視
  - **パフォーマンスの問題検出**: パフォーマンスの低下を検出し、最適化を提案
  - **通知設定**: パフォーマンス監視の結果をSlackやメールで通知
- `Assets/_Project/.github/workflows/code-review.yml`: コードレビューの自動化と管理
  - **プルリクエストの監視**: 新しいプルリクエストを監視し、コードレビューのプロセスを自動化
  - **レビュアーの割り当て**: プルリクエストに適切なレビュアーを自動的に割り当て
  - **通知設定**: コードレビューの進捗状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/documentation-update.yml`: ドキュメントの更新と管理
  - **ドキュメントの変更監視**: プロジェクト内のドキュメントの変更を監視し、最新の状態を維持
  - **ドキュメントの品質チェック**: ドキュメントの一貫性と品質をチェック
  - **通知設定**: ドキュメントの更新状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/backup-and-recovery.yml`: プロジェクトのバックアップとリカバリー
  - **定期的なバックアップの実行**: プロジェクトの定期的なバックアップを自動化
  - **リカバリープロセスのテスト**: バックアップからのリカバリー手順を定期的にテスト
  - **通知設定**: バックアップとリカバリーの状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/localization-management.yml`: ローカリゼーションの管理と更新
  - **ローカリゼーションファイルの監視**: ローカリゼーション関連のファイルの変更を監視
  - **翻訳の更新提案**: 新しいコンテンツに対する翻訳の更新を自動的に提案
  - **通知設定**: ローカリゼーションの更新状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/user-feedback-integration.yml`: ユーザーフィードバックの収集と統合
  - **フィードバックフォームの監視**: ユーザーフィードバックフォームの提出を監視
  - **フィードバックの分析**: 収集したフィードバックを分析し、改善点を特定
  - **通知設定**: ユーザーフィードバックの状況をSlackやメールで通知で追加
- `Assets/_Project/.github/workflows/analytics-and-reporting.yml`: 分析とレポーティングの自動化
  - **使用状況データの収集**: プロジェクトの使用状況データを定期的に収集
  - **レポートの生成**: 収集したデータに基づき、定期的なレポートを自動生成
  - **通知設定**: 分析とレポーティングの結果をSlackやメールで通知
- `Assets/_Project/.github/workflows/ai-integration.yml`: AIツールとの連携と自動化
  - **AIツールの監視**: AIツールのステータスとパフォーマンスを監視
  - **AI生成コンテンツの管理**: AIが生成したコンテンツのレビューと統合を自動化
  - **通知設定**: AIツールの連携状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/environment-setup.yml`: 開発環境のセットアップと管理
  - **依存関係のインストール**: プロジェクトの依存関係を自動的にインストール
  - **環境変数の管理**: 開発環境に必要な環境変数を設定
  - **通知設定**: 環境セットアップの状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/feature-flag-management.yml`: フィーチャーフラグの管理と展開
  - **フィーチャーフラグの監視**: フィーチャーフラグの状態を監視
  - **フラグの展開自動化**: 新しいフィーチャーフラグの展開を自動化
  - **通知設定**: フィーチャーフラグの管理状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/incident-management.yml`: インシデント管理と対応
  - **インシデントの監視**: プロジェクトのインシデントを監視
  - **対応プロセスの自動化**: インシデント対応のプロセスを自動化
  - **通知設定**: インシデントの状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/knowledge-base-management.yml`: ナレッジベースの管理と更新
  - **ナレッジベースの変更監視**: ナレッジベースの内容の変更を監視
  - **コンテンツの品質チェック**: ナレッジベースの一貫性と品質をチェック
  - **通知設定**: ナレッジベースの更新状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/community-engagement.yml`: コミュニティエンゲージメントと管理
  - **コミュニティフォーラムの監視**: コミュニティフォーラムのアクティビティを監視
  - **エンゲージメントの促進**: コミュニティメンバーとのエンゲージメントを促進するアクションを自動化
  - **通知設定**: コミュニティエンゲージメントの状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/legal-compliance.yml`: 法的コンプライアンスの監視と管理
  - **コンプライアンスチェックの実行**: プロジェクトが法的要件に準拠しているかを定期的にチェック
  - **ドキュメントの更新監視**: 法的ドキュメントの変更を監視し、最新の状態を維持
  - **通知設定**: 法的コンプライアンスの状況をSlackやメールで通知
- `Assets/_Project/.github/workflows/team-collaboration.yml`: チームコラボレーションの促進と管理
  - **コラボレーションツールの統合**: SlackやTrelloなどのコラボレーションツールと連携
  - **チームアクティビティの監視**: チームメンバーのアクティビティを監視し、コラボレーションを促進
  - **通知設定**: チームコラボレーションの状況をSlackやメールで通知
  