# 嗅覚センサーシステム詳細設計書

## 1. ドキュメント管理情報

- **ドキュメント種別**: 詳細技術設計書
- **生成元**: 嗅覚センサーシステム仕様書.md
- **対象読者**: 開発者、アーキテクト、実装担当者
- **作成日**: 2025年9月18日
- **プロジェクト**: Unity 6 3D ゲーム基盤プロジェクト（URP3D_Base01）

## 2. アーキテクチャ設計

### 2.1 システム配置戦略（Core/Feature層分離）

#### Core層配置 (`asterivo.Unity60.Core.Sensors.Olfactory`)
**基盤システムとインターフェース定義**
- **IScentSource**: 匂い発生源インターフェース
- **IScentSensor**: 嗅覚センサー基盤インターフェース
- **ScentData**: 匂いデータ構造体
- **ScentManager**: 匂い管理サービス（ServiceLocator登録）
- **ScentCloudPool**: ObjectPool最適化システム

#### Feature層配置 (`asterivo.Unity60.Features.AI.Sensors`)
**具体的実装とAI統合**
- **NPCOlfactorySensor**: NPC嗅覚センサー実装
- **PlayerScentSource**: プレイヤー匂い発生源
- **ScentBasedAIBehavior**: AI行動制御統合
- **OlfactoryEventChannels**: 嗅覚イベント定義

### 2.2 既存システム統合設計

#### イベント駆動アーキテクチャ統合
```csharp
// 既存のGameEventシステムを拡張
public class OlfactoryScentDetectedEvent : GameEvent<ScentDetectionData> { }
public class ScentEmissionEvent : GameEvent<ScentEmissionData> { }
public class ScentMaskingEvent : GameEvent<ScentMaskingData> { }
```

#### ServiceLocator統合
```csharp
// ScentManagerをグローバルサービスとして登録
ServiceLocator.Register<IScentManager>(scentManager);
```

#### CommandPattern統合
```csharp
// 匂い関連操作をコマンド化
public class EmitScentCommand : ICommand { }
public class MaskScentCommand : ICommand { }
```

## 3. Core層詳細設計

### 3.1 基盤インターフェース設計

#### IScentSource インターフェース
```csharp
namespace asterivo.Unity60.Core.Sensors.Olfactory
{
    public interface IScentSource
    {
        ScentProfile ScentProfile { get; }
        float EmissionRate { get; }
        bool IsActive { get; set; }
        Vector3 Position { get; }

        void StartEmission();
        void StopEmission();
        void EmitScent();
    }
}
```

#### IScentSensor インターフェース
```csharp
namespace asterivo.Unity60.Core.Sensors.Olfactory
{
    public interface IScentSensor
    {
        float DetectionRadius { get; }
        float Sensitivity { get; }
        bool IsActive { get; set; }

        IReadOnlyList<ScentDetectionResult> DetectedScents { get; }

        void UpdateDetection();
        bool CanDetectScent(ScentData scentData);
    }
}
```

### 3.2 データ構造設計

#### ScentData 構造体
```csharp
namespace asterivo.Unity60.Core.Sensors.Olfactory
{
    [System.Serializable]
    public struct ScentData
    {
        public ScentType type;
        public float intensity;
        public float radius;
        public Vector3 position;
        public float creationTime;
        public float duration;
        public ScentProfile profile;

        public bool IsExpired => Time.time - creationTime > duration;
        public float IntensityAtDistance(float distance) =>
            intensity * Mathf.Max(0, 1 - (distance / radius));
    }
}
```

#### ScentProfile ScriptableObject
```csharp
namespace asterivo.Unity60.Core.Sensors.Olfactory
{
    [CreateAssetMenu(menuName = "Olfactory/Scent Profile")]
    public class ScentProfile : ScriptableObject
    {
        [Header("基本設定")]
        public ScentType scentType;
        public float initialIntensity = 1.0f;
        public float baseDuration = 30.0f;
        public float baseRadius = 5.0f;
        public float expansionRate = 0.1f;
        public float decayRate = 0.05f;

        [Header("環境影響")]
        public float windInfluence = 1.0f;
        public float rainDecayMultiplier = 2.0f;
        public bool affectedByTemperature = true;

        [Header("視覚設定")]
        public Color debugColor = Color.yellow;
        public Material debugMaterial;

        [Header("AI反応設定")]
        public AIReactionProfile[] aiReactions;
    }
}
```

### 3.3 ScentManager設計

#### ScentManager Core実装
```csharp
namespace asterivo.Unity60.Core.Sensors.Olfactory
{
    public interface IScentManager : IService
    {
        void EmitScent(Vector3 position, ScentProfile profile, Transform source = null);
        IReadOnlyList<ScentData> GetScentsInRange(Vector3 center, float radius);
        void RegisterScentSource(IScentSource source);
        void UnregisterScentSource(IScentSource source);
        void MaskScent(Vector3 position, float radius, float maskStrength);

        // 環境効果
        void SetWindVector(Vector3 windDirection, float windStrength);
        void SetWeatherEffect(WeatherType weather, float intensity);
    }

    public class ScentManager : MonoBehaviour, IScentManager
    {
        [Header("パフォーマンス設定")]
        [SerializeField] private int maxActiveScentClouds = 100;
        [SerializeField] private float updateInterval = 0.1f;
        [SerializeField] private int cloudsPerFrameUpdate = 10;

        [Header("環境設定")]
        [SerializeField] private Vector3 windVector = Vector3.zero;
        [SerializeField] private WeatherType currentWeather = WeatherType.Clear;
        [SerializeField] private float weatherIntensity = 0.0f;

        // ObjectPool統合
        private ObjectPool<ScentCloud> _scentCloudPool;
        private List<ScentData> _activeScents = new List<ScentData>(100);
        private List<IScentSource> _registeredSources = new List<IScentSource>();

        // フレーム分散処理
        private int _updateIndex = 0;
        private float _lastUpdateTime;

        private void Awake()
        {
            InitializeObjectPool();
            ServiceLocator.Register<IScentManager>(this);
        }

        private void InitializeObjectPool()
        {
            _scentCloudPool = new ObjectPool<ScentCloud>(
                createFunc: CreateScentCloud,
                actionOnGet: OnGetScentCloud,
                actionOnRelease: OnReleaseScentCloud,
                actionOnDestroy: OnDestroyScentCloud,
                defaultCapacity: maxActiveScentClouds / 2,
                maxSize: maxActiveScentClouds
            );
        }

        private void Update()
        {
            if (Time.time - _lastUpdateTime >= updateInterval)
            {
                UpdateScentClouds();
                _lastUpdateTime = Time.time;
            }
        }

        private void UpdateScentClouds()
        {
            int endIndex = Mathf.Min(_updateIndex + cloudsPerFrameUpdate, _activeScents.Count);

            for (int i = _updateIndex; i < endIndex; i++)
            {
                if (i >= _activeScents.Count) break;

                var scent = _activeScents[i];
                if (UpdateScentData(ref scent))
                {
                    _activeScents[i] = scent;
                }
                else
                {
                    // 期限切れの匂いを削除
                    _activeScents.RemoveAt(i);
                    i--;
                    endIndex--;
                }
            }

            _updateIndex = (_updateIndex + cloudsPerFrameUpdate) % _activeScents.Count;
        }

        private bool UpdateScentData(ref ScentData scentData)
        {
            if (scentData.IsExpired)
                return false;

            float deltaTime = Time.time - scentData.creationTime;

            // 強度の減衰計算
            float decayRate = scentData.profile.decayRate;
            if (currentWeather == WeatherType.Rain)
                decayRate *= scentData.profile.rainDecayMultiplier;

            scentData.intensity = scentData.profile.initialIntensity *
                Mathf.Exp(-decayRate * deltaTime);

            // 範囲の拡大
            scentData.radius = scentData.profile.baseRadius +
                (scentData.profile.expansionRate * deltaTime);

            // 風の影響
            if (windVector.magnitude > 0.1f)
            {
                Vector3 windInfluence = windVector * scentData.profile.windInfluence *
                    Time.deltaTime;
                scentData.position += windInfluence;
            }

            return scentData.intensity > 0.01f; // 閾値以下で削除
        }

        public void EmitScent(Vector3 position, ScentProfile profile, Transform source = null)
        {
            if (_activeScents.Count >= maxActiveScentClouds)
            {
                // 最も古い匂いを削除
                RemoveOldestScent();
            }

            var scentData = new ScentData
            {
                type = profile.scentType,
                intensity = profile.initialIntensity,
                radius = profile.baseRadius,
                position = position,
                creationTime = Time.time,
                duration = profile.baseDuration,
                profile = profile
            };

            _activeScents.Add(scentData);

            // イベント発行
            ScentEmissionEvent.Raise(new ScentEmissionData
            {
                scentData = scentData,
                source = source
            });
        }

        public IReadOnlyList<ScentData> GetScentsInRange(Vector3 center, float radius)
        {
            var result = new List<ScentData>();

            for (int i = 0; i < _activeScents.Count; i++)
            {
                var scent = _activeScents[i];
                float distance = Vector3.Distance(center, scent.position);

                if (distance <= radius + scent.radius)
                {
                    result.Add(scent);
                }
            }

            return result;
        }
    }
}
```

## 4. Feature層詳細設計

### 4.1 NPCOlfactorySensor実装

```csharp
namespace asterivo.Unity60.Features.AI.Sensors
{
    public class NPCOlfactorySensor : MonoBehaviour, IScentSensor, IGameEventListener<ScentEmissionData>
    {
        [Header("センサー設定")]
        [SerializeField] private OlfactorySensorSettings settings;
        [SerializeField] private float detectionRadius = 10.0f;
        [SerializeField] private float sensitivity = 1.0f;
        [SerializeField] private float updateFrequency = 2.0f;

        [Header("AI統合")]
        [SerializeField] private AIStateMachine aiStateMachine;
        [SerializeField] private SuspicionController suspicionController;

        // IScentSensor実装
        public float DetectionRadius => detectionRadius;
        public float Sensitivity => sensitivity;
        public bool IsActive { get; set; } = true;
        public IReadOnlyList<ScentDetectionResult> DetectedScents => _detectedScents;

        // 内部状態
        private List<ScentDetectionResult> _detectedScents = new List<ScentDetectionResult>();
        private IScentManager _scentManager;
        private float _lastUpdateTime;
        private Coroutine _detectionCoroutine;

        // イベントチャネル
        [Header("イベント")]
        [SerializeField] private OlfactoryScentDetectedEvent scentDetectedEvent;
        [SerializeField] private ScentEmissionEvent scentEmissionEvent;

        private void Awake()
        {
            _scentManager = ServiceLocator.Get<IScentManager>();
            if (settings != null)
            {
                detectionRadius = settings.detectionRadius;
                sensitivity = settings.sensitivity;
                updateFrequency = settings.updateFrequency;
            }
        }

        private void OnEnable()
        {
            // イベント購読開始
            scentEmissionEvent.Subscribe(this);

            // 検知処理開始
            _detectionCoroutine = StartCoroutine(DetectionUpdateCoroutine());
        }

        private void OnDisable()
        {
            // イベント購読終了
            scentEmissionEvent.Unsubscribe(this);

            // 検知処理停止
            if (_detectionCoroutine != null)
            {
                StopCoroutine(_detectionCoroutine);
                _detectionCoroutine = null;
            }
        }

        private IEnumerator DetectionUpdateCoroutine()
        {
            while (IsActive)
            {
                UpdateDetection();
                yield return new WaitForSeconds(1.0f / updateFrequency);
            }
        }

        public void UpdateDetection()
        {
            if (!IsActive || _scentManager == null)
                return;

            _detectedScents.Clear();

            var nearbyScents = _scentManager.GetScentsInRange(transform.position, detectionRadius);

            foreach (var scentData in nearbyScents)
            {
                if (CanDetectScent(scentData))
                {
                    var result = CreateDetectionResult(scentData);
                    _detectedScents.Add(result);

                    // AI反応処理
                    ProcessScentDetection(result);
                }
            }
        }

        public bool CanDetectScent(ScentData scentData)
        {
            float distance = Vector3.Distance(transform.position, scentData.position);
            float effectiveIntensity = scentData.IntensityAtDistance(distance);

            // 感度チェック
            float detectionThreshold = GetDetectionThreshold(scentData.type);

            return effectiveIntensity >= detectionThreshold;
        }

        private float GetDetectionThreshold(ScentType scentType)
        {
            if (settings != null && settings.scentThresholds.ContainsKey(scentType))
            {
                return settings.scentThresholds[scentType] / sensitivity;
            }

            return 0.1f / sensitivity; // デフォルト閾値
        }

        private ScentDetectionResult CreateDetectionResult(ScentData scentData)
        {
            float distance = Vector3.Distance(transform.position, scentData.position);
            float intensity = scentData.IntensityAtDistance(distance);

            return new ScentDetectionResult
            {
                scentData = scentData,
                detectedIntensity = intensity,
                distance = distance,
                direction = (scentData.position - transform.position).normalized,
                confidence = CalculateConfidence(intensity, distance),
                detectionTime = Time.time
            };
        }

        private float CalculateConfidence(float intensity, float distance)
        {
            float distanceFactor = 1.0f - (distance / detectionRadius);
            float intensityFactor = Mathf.Clamp01(intensity);

            return (distanceFactor * intensityFactor) * sensitivity;
        }

        private void ProcessScentDetection(ScentDetectionResult result)
        {
            // AIの反応を設定から取得
            var reaction = GetAIReaction(result.scentData.type);
            if (reaction == null) return;

            // 疑心レベル調整
            if (suspicionController != null)
            {
                float suspicionIncrease = reaction.suspicionModifier * result.confidence;
                suspicionController.ModifySuspicion(suspicionIncrease);
            }

            // イベント発行
            scentDetectedEvent.Raise(new ScentDetectionData
            {
                detector = this,
                detectionResult = result,
                aiReaction = reaction
            });

            // AI状態変更判定
            if (aiStateMachine != null)
            {
                ProcessAIStateChange(result, reaction);
            }
        }

        private AIReactionProfile GetAIReaction(ScentType scentType)
        {
            if (settings != null && settings.aiReactions.ContainsKey(scentType))
            {
                return settings.aiReactions[scentType];
            }

            return null;
        }

        private void ProcessAIStateChange(ScentDetectionResult result, AIReactionProfile reaction)
        {
            switch (reaction.reactionType)
            {
                case AIReactionType.Investigate:
                    if (aiStateMachine.CurrentState.StateType == AIStateType.Patrol ||
                        aiStateMachine.CurrentState.StateType == AIStateType.Idle)
                    {
                        aiStateMachine.ChangeState(AIStateType.Investigating, new AIStateContext
                        {
                            targetPosition = result.scentData.position,
                            investigationReason = "Scent Detection",
                            priority = result.confidence
                        });
                    }
                    break;

                case AIReactionType.Alert:
                    if (result.confidence > 0.7f)
                    {
                        aiStateMachine.ChangeState(AIStateType.Alert, new AIStateContext
                        {
                            alertLevel = AlertLevel.High,
                            targetPosition = result.scentData.position
                        });
                    }
                    break;

                case AIReactionType.Flee:
                    aiStateMachine.ChangeState(AIStateType.Fleeing, new AIStateContext
                    {
                        fleeFromPosition = result.scentData.position,
                        fleeDistance = reaction.fleeDistance
                    });
                    break;

                case AIReactionType.Attracted:
                    aiStateMachine.ChangeState(AIStateType.Moving, new AIStateContext
                    {
                        targetPosition = result.scentData.position,
                        movementPriority = result.confidence
                    });
                    break;
            }
        }

        // IGameEventListener実装
        public void OnEventRaised(ScentEmissionData eventData)
        {
            // 新しい匂いが発生した場合の即座検知
            float distance = Vector3.Distance(transform.position, eventData.scentData.position);

            if (distance <= detectionRadius && CanDetectScent(eventData.scentData))
            {
                // 次回のUpdateDetectionを待たずに即座処理
                var result = CreateDetectionResult(eventData.scentData);
                _detectedScents.Add(result);
                ProcessScentDetection(result);
            }
        }
    }
}
```

### 4.2 PlayerScentSource実装

```csharp
namespace asterivo.Unity60.Features.Player
{
    public class PlayerScentSource : MonoBehaviour, IScentSource,
        IGameEventListener<PlayerHealthChangedEvent>
    {
        [Header("匂い設定")]
        [SerializeField] private ScentProfile normalScentProfile;
        [SerializeField] private ScentProfile bleedingScentProfile;
        [SerializeField] private ScentProfile injuredScentProfile;

        [Header("発生設定")]
        [SerializeField] private float normalEmissionRate = 5.0f;
        [SerializeField] private float bleedingEmissionRate = 1.0f;
        [SerializeField] private float injuredEmissionRate = 2.0f;

        [Header("条件設定")]
        [SerializeField] private float bleedingHealthThreshold = 0.3f;
        [SerializeField] private float injuredHealthThreshold = 0.7f;

        // IScentSource実装
        public ScentProfile ScentProfile { get; private set; }
        public float EmissionRate { get; private set; }
        public bool IsActive { get; set; } = true;
        public Vector3 Position => transform.position;

        // 内部状態
        private IScentManager _scentManager;
        private PlayerHealth _playerHealth;
        private Coroutine _emissionCoroutine;
        private PlayerScentState _currentScentState = PlayerScentState.Normal;

        // イベント
        [Header("イベント")]
        [SerializeField] private PlayerHealthChangedEvent healthChangedEvent;

        private void Awake()
        {
            _scentManager = ServiceLocator.Get<IScentManager>();
            _playerHealth = GetComponent<PlayerHealth>();

            UpdateScentProfile();
        }

        private void OnEnable()
        {
            healthChangedEvent.Subscribe(this);
            _scentManager?.RegisterScentSource(this);
            StartEmission();
        }

        private void OnDisable()
        {
            healthChangedEvent.Unsubscribe(this);
            _scentManager?.UnregisterScentSource(this);
            StopEmission();
        }

        public void StartEmission()
        {
            if (IsActive && _emissionCoroutine == null)
            {
                _emissionCoroutine = StartCoroutine(EmissionCoroutine());
            }
        }

        public void StopEmission()
        {
            if (_emissionCoroutine != null)
            {
                StopCoroutine(_emissionCoroutine);
                _emissionCoroutine = null;
            }
        }

        public void EmitScent()
        {
            if (IsActive && _scentManager != null && ScentProfile != null)
            {
                _scentManager.EmitScent(Position, ScentProfile, transform);
            }
        }

        private IEnumerator EmissionCoroutine()
        {
            while (IsActive)
            {
                EmitScent();
                yield return new WaitForSeconds(1.0f / EmissionRate);
            }
        }

        private void UpdateScentProfile()
        {
            if (_playerHealth == null) return;

            float healthRatio = _playerHealth.CurrentHealth / _playerHealth.MaxHealth;
            PlayerScentState newState;

            if (healthRatio <= bleedingHealthThreshold)
            {
                newState = PlayerScentState.Bleeding;
                ScentProfile = bleedingScentProfile;
                EmissionRate = bleedingEmissionRate;
            }
            else if (healthRatio <= injuredHealthThreshold)
            {
                newState = PlayerScentState.Injured;
                ScentProfile = injuredScentProfile;
                EmissionRate = injuredEmissionRate;
            }
            else
            {
                newState = PlayerScentState.Normal;
                ScentProfile = normalScentProfile;
                EmissionRate = normalEmissionRate;
            }

            if (newState != _currentScentState)
            {
                _currentScentState = newState;
                RestartEmission();
            }
        }

        private void RestartEmission()
        {
            StopEmission();
            StartEmission();
        }

        // IGameEventListener実装
        public void OnEventRaised(PlayerHealthChangedEvent eventData)
        {
            UpdateScentProfile();
        }
    }
}
```

## 5. ScriptableObject設定システム

### 5.1 OlfactorySensorSettings

```csharp
namespace asterivo.Unity60.Core.Sensors.Olfactory
{
    [CreateAssetMenu(menuName = "Olfactory/Sensor Settings")]
    public class OlfactorySensorSettings : ScriptableObject
    {
        [Header("基本設定")]
        public float detectionRadius = 10.0f;
        public float sensitivity = 1.0f;
        public float updateFrequency = 2.0f;

        [Header("匂い別閾値")]
        public ScentThresholdEntry[] scentThresholds;

        [Header("AI反応設定")]
        public AIReactionEntry[] aiReactions;

        [Header("デバッグ設定")]
        public bool showDebugGizmos = true;
        public Color detectionRangeColor = Color.yellow;

        // 辞書形式でのアクセス用
        private Dictionary<ScentType, float> _scentThresholdDict;
        private Dictionary<ScentType, AIReactionProfile> _aiReactionDict;

        public Dictionary<ScentType, float> ScentThresholds
        {
            get
            {
                if (_scentThresholdDict == null)
                {
                    _scentThresholdDict = scentThresholds.ToDictionary(x => x.scentType, x => x.threshold);
                }
                return _scentThresholdDict;
            }
        }

        public Dictionary<ScentType, AIReactionProfile> AIReactions
        {
            get
            {
                if (_aiReactionDict == null)
                {
                    _aiReactionDict = aiReactions.ToDictionary(x => x.scentType, x => x.reaction);
                }
                return _aiReactionDict;
            }
        }
    }

    [System.Serializable]
    public class ScentThresholdEntry
    {
        public ScentType scentType;
        public float threshold = 0.1f;
    }

    [System.Serializable]
    public class AIReactionEntry
    {
        public ScentType scentType;
        public AIReactionProfile reaction;
    }
}
```

## 6. パフォーマンス最適化設計

### 6.1 ObjectPool統合

```csharp
namespace asterivo.Unity60.Core.Sensors.Olfactory
{
    public class ScentCloudPool : IObjectPool<ScentCloud>
    {
        private readonly Queue<ScentCloud> _pool = new Queue<ScentCloud>();
        private readonly int _maxPoolSize;
        private int _createdCount = 0;

        public ScentCloudPool(int maxPoolSize = 200)
        {
            _maxPoolSize = maxPoolSize;
        }

        public ScentCloud Get()
        {
            if (_pool.Count > 0)
            {
                return _pool.Dequeue();
            }

            return CreateNewScentCloud();
        }

        public void Release(ScentCloud scentCloud)
        {
            if (_pool.Count < _maxPoolSize)
            {
                scentCloud.Reset();
                _pool.Enqueue(scentCloud);
            }
            else
            {
                // プールが満杯の場合は破棄
                Object.Destroy(scentCloud.gameObject);
                _createdCount--;
            }
        }

        private ScentCloud CreateNewScentCloud()
        {
            var go = new GameObject("ScentCloud");
            var scentCloud = go.AddComponent<ScentCloud>();
            _createdCount++;
            return scentCloud;
        }
    }
}
```

### 6.2 空間分割最適化

```csharp
namespace asterivo.Unity60.Core.Sensors.Olfactory
{
    public class SpatialScentIndex
    {
        private readonly Dictionary<Vector2Int, List<ScentData>> _spatialGrid;
        private readonly float _cellSize;

        public SpatialScentIndex(float cellSize = 10.0f)
        {
            _cellSize = cellSize;
            _spatialGrid = new Dictionary<Vector2Int, List<ScentData>>();
        }

        public void AddScent(ScentData scentData)
        {
            var cell = WorldToCell(scentData.position);

            if (!_spatialGrid.ContainsKey(cell))
            {
                _spatialGrid[cell] = new List<ScentData>();
            }

            _spatialGrid[cell].Add(scentData);
        }

        public IEnumerable<ScentData> GetScentsInRange(Vector3 center, float radius)
        {
            var centerCell = WorldToCell(center);
            int cellRadius = Mathf.CeilToInt(radius / _cellSize);

            for (int x = centerCell.x - cellRadius; x <= centerCell.x + cellRadius; x++)
            {
                for (int y = centerCell.y - cellRadius; y <= centerCell.y + cellRadius; y++)
                {
                    var cell = new Vector2Int(x, y);

                    if (_spatialGrid.ContainsKey(cell))
                    {
                        foreach (var scent in _spatialGrid[cell])
                        {
                            float distance = Vector3.Distance(center, scent.position);
                            if (distance <= radius)
                            {
                                yield return scent;
                            }
                        }
                    }
                }
            }
        }

        private Vector2Int WorldToCell(Vector3 worldPos)
        {
            return new Vector2Int(
                Mathf.FloorToInt(worldPos.x / _cellSize),
                Mathf.FloorToInt(worldPos.z / _cellSize)
            );
        }
    }
}
```

## 7. デバッグ・可視化システム

### 7.1 エディタ拡張

```csharp
#if UNITY_EDITOR
namespace asterivo.Unity60.Core.Sensors.Olfactory.Editor
{
    [CustomEditor(typeof(NPCOlfactorySensor))]
    public class NPCOlfactorySensorEditor : Editor
    {
        private NPCOlfactorySensor _sensor;

        private void OnEnable()
        {
            _sensor = (NPCOlfactorySensor)target;
        }

        public override void OnInspectorGUI()
        {
            DrawDefaultInspector();

            EditorGUILayout.Space();
            EditorGUILayout.LabelField("Debug Information", EditorStyles.boldLabel);

            if (Application.isPlaying)
            {
                EditorGUILayout.LabelField($"Detected Scents: {_sensor.DetectedScents.Count}");

                if (_sensor.DetectedScents.Count > 0)
                {
                    EditorGUI.indentLevel++;
                    foreach (var detection in _sensor.DetectedScents)
                    {
                        EditorGUILayout.LabelField($"{detection.scentData.type}: {detection.detectedIntensity:F3}");
                    }
                    EditorGUI.indentLevel--;
                }
            }

            if (GUILayout.Button("Force Update Detection"))
            {
                _sensor.UpdateDetection();
            }
        }

        private void OnSceneGUI()
        {
            if (_sensor == null) return;

            // 検知範囲の描画
            Handles.color = Color.yellow;
            Handles.DrawWireArc(_sensor.transform.position, Vector3.up, Vector3.forward, 360f, _sensor.DetectionRadius);

            // 検知した匂いの描画
            if (Application.isPlaying)
            {
                foreach (var detection in _sensor.DetectedScents)
                {
                    Handles.color = GetScentColor(detection.scentData.type);
                    Handles.DrawLine(_sensor.transform.position, detection.scentData.position);
                    Handles.DrawWireDisc(detection.scentData.position, Vector3.up, detection.scentData.radius);
                }
            }
        }

        private Color GetScentColor(ScentType scentType)
        {
            return scentType switch
            {
                ScentType.Blood => Color.red,
                ScentType.Food => Color.green,
                ScentType.Decay => Color.magenta,
                ScentType.Smoke => Color.gray,
                _ => Color.white
            };
        }
    }
}
#endif
```

## 8. 実装フェーズ・スケジュール

### Phase 1: Core層基盤実装（3-4日）
- [ ] **Day 1-2**: 基本インターフェース・データ構造
  - IScentSource, IScentSensor, ScentData実装
  - ScentProfile ScriptableObject作成
  - 基本的なScentManager実装

- [ ] **Day 3-4**: ObjectPool統合・パフォーマンス最適化
  - ScentCloudPool実装
  - 空間分割システム基盤
  - フレーム分散処理実装

### Phase 2: Feature層実装（4-5日）
- [ ] **Day 5-6**: NPCOlfactorySensor実装
  - 基本検知機能
  - AI統合システム
  - イベント連携

- [ ] **Day 7-8**: PlayerScentSource実装
  - プレイヤー状態連動
  - 動的匂い発生システム

- [ ] **Day 9**: OlfactorySensorSettings・設定システム
  - ScriptableObject設定
  - エディタ拡張UI

### Phase 3: 統合・テスト・拡張（3-4日）
- [ ] **Day 10-11**: システム統合テスト
  - イベントフロー検証
  - パフォーマンステスト
  - バグ修正

- [ ] **Day 12-13**: 拡張機能実装
  - 風システム統合
  - 天候効果
  - マスキングシステム

## 9. テスト戦略

### 9.1 単体テスト
```csharp
namespace asterivo.Unity60.Tests.Core.Sensors.Olfactory
{
    [TestFixture]
    public class ScentManagerTests
    {
        private ScentManager _scentManager;
        private ScentProfile _testProfile;

        [SetUp]
        public void SetUp()
        {
            var go = new GameObject("TestScentManager");
            _scentManager = go.AddComponent<ScentManager>();

            _testProfile = ScriptableObject.CreateInstance<ScentProfile>();
            _testProfile.scentType = ScentType.Blood;
            _testProfile.initialIntensity = 1.0f;
            _testProfile.baseDuration = 10.0f;
        }

        [Test]
        public void EmitScent_CreatesNewScentData()
        {
            // Arrange
            Vector3 position = Vector3.zero;

            // Act
            _scentManager.EmitScent(position, _testProfile);

            // Assert
            var scents = _scentManager.GetScentsInRange(position, 1.0f);
            Assert.AreEqual(1, scents.Count);
            Assert.AreEqual(ScentType.Blood, scents[0].type);
        }

        [Test]
        public void GetScentsInRange_ReturnsCorrectScents()
        {
            // Arrange
            _scentManager.EmitScent(Vector3.zero, _testProfile);
            _scentManager.EmitScent(Vector3.one * 20, _testProfile);

            // Act
            var nearScents = _scentManager.GetScentsInRange(Vector3.zero, 5.0f);

            // Assert
            Assert.AreEqual(1, nearScents.Count);
        }
    }
}
```

### 9.2 統合テスト
```csharp
namespace asterivo.Unity60.Tests.Features.AI.Sensors
{
    [TestFixture]
    public class OlfactorySystemIntegrationTests
    {
        [UnityTest]
        public IEnumerator NPCSensor_DetectsPlayerScent()
        {
            // Arrange
            var playerGo = SetupPlayer();
            var npcGo = SetupNPC();

            var playerScentSource = playerGo.GetComponent<PlayerScentSource>();
            var npcSensor = npcGo.GetComponent<NPCOlfactorySensor>();

            // プレイヤーを出血状態にする
            var playerHealth = playerGo.GetComponent<PlayerHealth>();
            playerHealth.TakeDamage(playerHealth.MaxHealth * 0.8f);

            // Act
            playerScentSource.EmitScent();

            // 検知まで待機
            yield return new WaitForSeconds(1.0f);

            // Assert
            Assert.IsTrue(npcSensor.DetectedScents.Count > 0);
            Assert.AreEqual(ScentType.Blood, npcSensor.DetectedScents[0].scentData.type);
        }
    }
}
```

## 10. リスクと軽減策

### 10.1 パフォーマンスリスク
**リスク**: 大量の匂いオブジェクトによるメモリ・CPU負荷
**軽減策**:
- ObjectPool徹底活用
- 空間分割による検索最適化
- フレーム分散処理
- 適切な匂いの生存期間設定

### 10.2 ゲームプレイバランスリスク
**リスク**: 匂いシステムが難易度を過度に上げる可能性
**軽減策**:
- ScriptableObject による調整可能な設定
- プレイテストに基づく数値調整
- 段階的難易度設定
- プレイヤー向けの対策手段（マスキングアイテム等）

## 11. 将来拡張計画

### 11.1 風システム統合
- WindManager との連携
- 動的風向き・風力による匂い移動
- 室内・屋外環境での風の影響差

### 11.2 プレイヤー嗅覚システム
- プレイヤーが匂いを検知する機能
- 探偵モードでの匂いの可視化
- 匂いを手がかりとした謎解き要素

### 11.3 マルチレイヤー匂いシステム
- 複数の匂いの混合・相殺効果
- 匂いの強さによる優先度システム
- 化学反応的な匂いの変化

## 12. まとめ

本詳細設計書により、嗅覚センサーシステムの実装が可能になります。既存のイベント駆動アーキテクチャ・コマンドパターン・ServiceLocatorパターンとの統合により、拡張性と保守性を保ちながら、リアルな匂い検知システムを実現できます。

### 実装優先度
1. **最優先**: Core層基盤（IScentSource, ScentManager）
2. **高優先**: NPCOlfactorySensor実装
3. **中優先**: PlayerScentSource・設定システム
4. **低優先**: 拡張機能（風・天候・マスキング）

### 期待効果
- ゲームプレイの深化（新しいステルス要素）
- AI行動の多様化（匂いに基づく追跡・逃避）
- 没入感の向上（より現実的な感覚システム）
- 戦略性の向上（匂い管理という新しい要素）