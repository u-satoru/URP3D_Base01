# オブジェクトプール活用ガイド

## 概要：オブジェクトプールとは？

オブジェクトプールは、**頻繁に生成・破棄されるオブジェクトを、あらかじめ一定数生成して「プール」に貯めておき、必要に応じて貸し出し・返却することで再利用する**デザインパターンです。これにより、`Instantiate()`と`Destroy()`の呼び出しに伴うCPU負荷やガベージコレクション（GC）によるパフォーマンスの低下を大幅に削減できます。

## 現行アーキテクチャとのシナジー

このプロジェクトの洗練されたアーキテクチャ（イベント駆動＋コマンドパターン）にオブジェクトプールを導入することは、パフォーマンスを劇的に向上させ、よりスケーラブルなゲームシステムを構築する上で非常に有効です。既存のシステムとスムーズに連携させることができます。

---

## プロジェクトにおける具体的な活用方法

### 1. スキルやアイテムのVFX（視覚効果）と投射物

現在実装したアイテムシステムは、オブジェクトプールを統合するのに最適な場所です。

- **何をプールするか**:
    - 回復魔法のエフェクト（パーティクル）
    - 攻撃魔法の弾（ファイアボールなど）
    - 敵にダメージを与えた際のヒットエフェクト
    - ダメージ数値のフローティングテキスト

- **どのように統合するか**:
    1. 汎用的な`ObjectPool<T>`クラスを作成します。
    2. `VFXPoolManager`のような、パーティクルエフェクト専用のプールを管理するシングルトンまたはサービスを構築します。
    3. `ItemData`や`SkillData`に、`PlayEffectCommandDefinition`のような新しいコマンド定義を追加します。この定義は、再生したいエフェクトのPrefabやIDを保持します。
    4. `CommandInvoker`は`PlayEffectCommandDefinition`を受け取ると、`PlayEffectCommand`を生成します。
    5. `PlayEffectCommand`の`Execute()`メソッドは、`Instantiate()`を呼び出す代わりに`VFXPoolManager.Get("HealEffect")`のようにプールからエフェクトオブジェクトを取得し、指定座標で再生します。
    6. 再生が終了したエフェクトは、自動的にプールに返却されます。

- **どのようなメリットがあるか**:
    プレイヤーがアイテムやスキルを連打しても、エフェクトの生成・破棄によるパフォーマンスの低下が一切なくなります。ゲームの応答性が向上し、特にエフェクトが多用される派手な戦闘シーンで安定したフレームレートを維持できます。

### 2. コマンドオブジェクト自体のプール化（上級者向け）

これはより高度な最適化ですが、このプロジェクトのアーキテクチャだからこそ考えられるエレガントな活用法です。

- **何をプールするか**:
    - `HealCommand`や`DamageCommand`など、`ICommand`を実装したPOCO（Plain Old C# Object）クラスのインスタンス。

- **どのように統合するか**:
    1. `CommandInvoker`の`CreateCommandFromDefinition`メソッドを修正します。
    2. `new HealCommand(...)`とする代わりに、`CommandPool.Get<HealCommand>()`のようにコマンド専用のプールからインスタンスを取得します。
    3. 取得したコマンドインスタンスに、`Initialize(target, amount)`のようなメソッドで新しいデータを設定します。
    4. `CommandInvoker`のUndo/Redoスタックからコマンドが完全に不要になったタイミング（例：新しいコマンドが実行されてRedoスタックがクリアされた時）で、コマンドをプールに返却します。

- **どのようなメリットがあるか**:
    コマンドは軽量なクラスですが、毎フレームのように大量のコマンドが生成されるような極端な状況（例：猛毒による毎フレームダメージなど）では、この方法がGCの発生を完全に抑制し、究極のパフォーマンスチューニングを実現します。

### 3. AIエージェントや破壊可能なオブジェクト

ステルスゲームやアクションゲームでは、多数の敵キャラクターや破壊可能なオブジェクトが登場することがよくあります。

- **何をプールするか**:
    - 敵キャラクターのGameObject
    - 破壊可能な樽や箱などのGameObject

- **どのように統合するか**:
    1. `EnemyPool`や`DestructiblePool`といったプールを作成します。
    2. `EnemySpawner`のようなシステムが、敵を出現させる際に`Instantiate()`するのではなく`EnemyPool.Get()`を呼び出します。
    3. 敵が倒された時、その敵の`HealthComponent`が`OnDeath`イベントを発行します。
    4. `EnemyPool`自身が`OnDeath`イベントをリッスンし、倒された敵オブジェクトを自動的に回収（非アクティブ化し、状態をリセットしてプールに戻す）します。

- **どのようなメリットがあるか**:
    敵の大群が一度に出現・消滅するようなシーンでも、スムーズなゲーム体験を提供できます。ステージの開始時に必要な敵をすべてプールしておけば、ゲーム中の負荷は最小限になります。

---

## 実装の推奨事項

まずは最も効果がわかりやすく、実装しやすい**「1. スキルやアイテムのVFXと投射物」**から着手するのが良いでしょう。汎用的なオブジェクトプールクラスを一つ作成すれば、エフェクト、投射物、UIなど様々な要素に使い回すことができ、プロジェクト全体の品質が向上します。
