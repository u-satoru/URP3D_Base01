# éšå±¤åŒ–ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³è©³ç´°è¨­è¨ˆæ›¸

## æ–‡æ›¸ç®¡ç†æƒ…å ±
- **ä½œæˆæ—¥**: 2025å¹´9æœˆ18æ—¥
- **æœ€çµ‚æ›´æ–°**: 2025å¹´9æœˆ19æ—¥ï¼ˆå®Ÿè£…å®Œäº†ï¼‰
- **è¨­è¨ˆå¯¾è±¡**: éšå±¤åŒ–ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ã‚·ã‚¹ãƒ†ãƒ 
- **è¨­è¨ˆæ ¹æ‹ **: éšå±¤åŒ–ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ææ¡ˆè©•ä¾¡ãƒ¬ãƒãƒ¼ãƒˆï¼ˆâ­â­â­â­â­è©•ä¾¡ï¼‰
- **ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**: Unity 6 3Dã‚²ãƒ¼ãƒ åŸºç›¤ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆï¼ˆURP3D_Base01ï¼‰
- **ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æº–æ‹ **: Core/Featuresåˆ†é›¢åŸå‰‡ã€asterivo.Unity60.*åå‰ç©ºé–“è¦ç´„
- **å®Ÿè£…çŠ¶æ³**: âœ… **å®Œäº†** - Phase 1, 2, 3 ã™ã¹ã¦å®Ÿè£…å®Œäº†

## è¨­è¨ˆæ¦‚è¦

### è¨­è¨ˆãƒ“ã‚¸ãƒ§ãƒ³
éšå±¤åŒ–ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã¯ã€è¤‡é›‘ãªçŠ¶æ…‹é·ç§»ã‚’æ§‹é€ åŒ–ãƒ»æ•´ç†ã—ã€å†åˆ©ç”¨æ€§ã¨ä¿å®ˆæ€§ã‚’å¤§å¹…ã«å‘ä¸Šã•ã›ã‚‹ã‚·ã‚¹ãƒ†ãƒ ã§ã™ã€‚Coreå±¤ã§ã€Œä»•çµ„ã¿ã€ã‚’æä¾›ã—ã€Featureså±¤ã§ã€Œå…·ä½“çš„ãªå®Ÿè£…ã€ã‚’è¡Œã†ã€å®Œå…¨ãªã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£åˆ†é›¢ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

### æœŸå¾…åŠ¹æœ
- **å†åˆ©ç”¨æ€§å‘ä¸Š**: åŒã˜éšå±¤åŒ–åŸºç›¤ã‚’Playerã€AIã€Cameraã§æ´»ç”¨
- **ä¿å®ˆæ€§å‘ä¸Š**: è¤‡é›‘ãªçŠ¶æ…‹ãƒ­ã‚¸ãƒƒã‚¯ã®æ§‹é€ åŒ–ãƒ»æ•´ç†
- **æ‹¡å¼µæ€§ç¢ºä¿**: æ–°ã‚¸ãƒ£ãƒ³ãƒ«ã¸ã®å¯¾å¿œå¼·åŒ–
- **é–‹ç™ºåŠ¹ç‡åŒ–**: çŠ¶æ…‹é–¢ä¿‚ã®ç†è§£å‘ä¸Šã€ãƒ‡ãƒãƒƒã‚°å®¹æ˜“æ€§

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£è¨­è¨ˆ

### Core/Featuresåˆ†é›¢åŸå‰‡

```mermaid
flowchart TB
    subgraph "Core Layer - éšå±¤åŒ–ã®ä»•çµ„ã¿"
        A["asterivo.Unity60.Core.StateMachine"]
        A1["HierarchicalState<T>"]
        A2["IHierarchicalState<T>"]
        A3["StateTransitionManager"]
        A4["StateDebugger"]

        A --> A1
        A --> A2
        A --> A3
        A --> A4
    end

    subgraph "Features Layer - å…·ä½“çš„ãªå®Ÿè£…"
        B["asterivo.Unity60.Features.Player.States"]
        B1["PlayerGroundedState"]
        B2["PlayerAirborneState"]

        C["asterivo.Unity60.Features.AI.States"]
        C1["AICombatState"]
        C2["AIAlertState"]

        D["asterivo.Unity60.Features.Camera.States"]
        D1["ThirdPersonState"]

        B --> B1
        B --> B2
        C --> C1
        C --> C2
        D --> D1
    end

    A1 --> B1
    A1 --> B2
    A1 --> C1
    A1 --> C2
    A1 --> D1

    classDef coreLayer fill:#e1f5fe,stroke:#0277bd,stroke-width:2px,color:#000
    classDef featureLayer fill:#e8f5e8,stroke:#388e3c,stroke-width:2px,color:#000
    classDef implementation fill:#fff3e0,stroke:#f57c00,stroke-width:1px,color:#000

    class A,A1,A2,A3,A4 coreLayer
    class B,C,D featureLayer
    class B1,B2,C1,C2,D1 implementation
```

### åå‰ç©ºé–“è¨­è¨ˆ

#### Coreå±¤ï¼ˆåŸºç›¤æä¾›ï¼‰
- **asterivo.Unity60.Core.StateMachine**: éšå±¤åŒ–ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ã®åŸºç›¤
- **asterivo.Unity60.Core.StateMachine.Interfaces**: ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹å®šç¾©
- **asterivo.Unity60.Core.StateMachine.Debug**: ãƒ‡ãƒãƒƒã‚°æ”¯æ´æ©Ÿèƒ½

#### Featureså±¤ï¼ˆå…·ä½“å®Ÿè£…ï¼‰
- **asterivo.Unity60.Features.Player.StateMachine.Hierarchical**: ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼éšå±¤çŠ¶æ…‹
- **asterivo.Unity60.Features.AI.StateMachine.Hierarchical**: AIéšå±¤çŠ¶æ…‹
- **asterivo.Unity60.Features.Camera.StateMachine.Hierarchical**: ã‚«ãƒ¡ãƒ©éšå±¤çŠ¶æ…‹

## Coreå±¤è©³ç´°è¨­è¨ˆ

### 1. HierarchicalState<T> æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹

```csharp
namespace asterivo.Unity60.Core.StateMachine
{
    public abstract class HierarchicalState<TContext> : IState<TContext>, IHierarchicalState<TContext>
    {
        // å­çŠ¶æ…‹ç®¡ç†
        protected Dictionary<string, IState<TContext>> childStates;
        protected IState<TContext> currentChildState;
        protected string defaultChildStateKey;

        // çŠ¶æ…‹å±¥æ­´ç®¡ç†
        protected Stack<string> stateHistory;
        protected int maxHistorySize = 10;

        // ãƒ‡ãƒãƒƒã‚°ãƒ»ç›£è¦–æ©Ÿèƒ½
        protected StateDebugInfo debugInfo;
        protected bool enableDebugLogging = false;

        public HierarchicalState()
        {
            childStates = new Dictionary<string, IState<TContext>>();
            stateHistory = new Stack<string>();
            debugInfo = new StateDebugInfo();
            InitializeChildStates();
        }

        #region IState<TContext> Implementation

        public virtual void Enter(TContext context)
        {
            LogStateTransition("Enter", GetType().Name);

            // è¦ªçŠ¶æ…‹ã®Enterå‡¦ç†
            OnParentEnter(context);

            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå­çŠ¶æ…‹ã¸ã®é·ç§»
            if (!string.IsNullOrEmpty(defaultChildStateKey))
            {
                TransitionToChild(defaultChildStateKey, context);
            }
        }

        public virtual void Update(TContext context)
        {
            // è¦ªçŠ¶æ…‹ã®Updateå‡¦ç†
            OnParentUpdate(context);

            // ç¾åœ¨ã®å­çŠ¶æ…‹ã®Updateå‡¦ç†
            currentChildState?.Update(context);
        }

        public virtual void Exit(TContext context)
        {
            LogStateTransition("Exit", GetType().Name);

            // å­çŠ¶æ…‹ã®çµ‚äº†å‡¦ç†
            currentChildState?.Exit(context);
            currentChildState = null;

            // è¦ªçŠ¶æ…‹ã®Exitå‡¦ç†
            OnParentExit(context);
        }

        #endregion

        #region IHierarchicalState<TContext> Implementation

        public void TransitionToChild(string childStateKey, TContext context)
        {
            if (!childStates.ContainsKey(childStateKey))
            {
                LogError($"Child state '{childStateKey}' not found in {GetType().Name}");
                return;
            }

            // ç¾åœ¨ã®å­çŠ¶æ…‹ã‚’çµ‚äº†
            if (currentChildState != null)
            {
                currentChildState.Exit(context);
                RecordStateHistory(GetCurrentChildStateKey());
            }

            // æ–°ã—ã„å­çŠ¶æ…‹ã«é·ç§»
            currentChildState = childStates[childStateKey];
            currentChildState.Enter(context);

            LogStateTransition("ChildTransition", $"{GetType().Name} -> {childStateKey}");
        }

        public bool HasChildState(string childStateKey)
        {
            return childStates.ContainsKey(childStateKey);
        }

        public string GetCurrentChildStateKey()
        {
            if (currentChildState == null) return null;

            return childStates.FirstOrDefault(kvp => kvp.Value == currentChildState).Key;
        }

        public IReadOnlyDictionary<string, IState<TContext>> GetChildStates()
        {
            return childStates.AsReadOnly();
        }

        public bool CanTransitionToChild(string childStateKey, TContext context)
        {
            return HasChildState(childStateKey) && ValidateChildTransition(childStateKey, context);
        }

        #endregion

        #region æŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…å¿…é ˆï¼‰

        /// <summary>
        /// å­çŠ¶æ…‹ã®åˆæœŸåŒ–ã‚’è¡Œã†
        /// </summary>
        protected abstract void InitializeChildStates();

        /// <summary>
        /// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå­çŠ¶æ…‹ã‚­ãƒ¼ã‚’è¨­å®šã™ã‚‹
        /// </summary>
        protected abstract string GetDefaultChildStateKey();

        /// <summary>
        /// å­çŠ¶æ…‹ã¸ã®é·ç§»å¯å¦ã‚’æ¤œè¨¼ã™ã‚‹
        /// </summary>
        protected virtual bool ValidateChildTransition(string childStateKey, TContext context)
        {
            return true;
        }

        #endregion

        #region ä»®æƒ³ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰å¯èƒ½ï¼‰

        protected virtual void OnParentEnter(TContext context) { }
        protected virtual void OnParentUpdate(TContext context) { }
        protected virtual void OnParentExit(TContext context) { }

        #endregion

        #region ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰

        protected void AddChildState(string key, IState<TContext> state)
        {
            if (childStates.ContainsKey(key))
            {
                LogWarning($"Child state '{key}' already exists in {GetType().Name}. Overwriting.");
            }

            childStates[key] = state;
        }

        protected void RemoveChildState(string key)
        {
            if (childStates.ContainsKey(key))
            {
                if (currentChildState == childStates[key])
                {
                    currentChildState = null;
                }
                childStates.Remove(key);
            }
        }

        private void RecordStateHistory(string stateKey)
        {
            if (string.IsNullOrEmpty(stateKey)) return;

            stateHistory.Push(stateKey);

            // å±¥æ­´ã‚µã‚¤ã‚ºåˆ¶é™
            while (stateHistory.Count > maxHistorySize)
            {
                var tempStack = new Stack<string>();
                for (int i = 0; i < maxHistorySize; i++)
                {
                    tempStack.Push(stateHistory.Pop());
                }
                stateHistory = tempStack;
            }
        }

        public string GetPreviousChildState()
        {
            return stateHistory.Count > 0 ? stateHistory.Peek() : null;
        }

        public IReadOnlyCollection<string> GetStateHistory()
        {
            return stateHistory.ToArray().AsReadOnly();
        }

        #endregion

        #region ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½

        private void LogStateTransition(string transitionType, string details)
        {
            if (!enableDebugLogging) return;

            debugInfo.RecordTransition(transitionType, details, DateTime.UtcNow);

            #if UNITY_EDITOR || DEVELOPMENT_BUILD
            UnityEngine.Debug.Log($"[HierarchicalState] {transitionType}: {details}");
            #endif
        }

        private void LogError(string message)
        {
            #if UNITY_EDITOR || DEVELOPMENT_BUILD
            UnityEngine.Debug.LogError($"[HierarchicalState Error] {message}");
            #endif
        }

        private void LogWarning(string message)
        {
            #if UNITY_EDITOR || DEVELOPMENT_BUILD
            UnityEngine.Debug.LogWarning($"[HierarchicalState Warning] {message}");
            #endif
        }

        public StateDebugInfo GetDebugInfo()
        {
            return debugInfo;
        }

        public void SetDebugLogging(bool enabled)
        {
            enableDebugLogging = enabled;
        }

        #endregion
    }
}
```

### 2. IHierarchicalState<T> ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

```csharp
namespace asterivo.Unity60.Core.StateMachine.Interfaces
{
    public interface IHierarchicalState<TContext> : IState<TContext>
    {
        /// <summary>
        /// æŒ‡å®šã•ã‚ŒãŸå­çŠ¶æ…‹ã«é·ç§»ã™ã‚‹
        /// </summary>
        void TransitionToChild(string childStateKey, TContext context);

        /// <summary>
        /// æŒ‡å®šã•ã‚ŒãŸå­çŠ¶æ…‹ãŒå­˜åœ¨ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        /// </summary>
        bool HasChildState(string childStateKey);

        /// <summary>
        /// ç¾åœ¨ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå­çŠ¶æ…‹ã®ã‚­ãƒ¼ã‚’å–å¾—
        /// </summary>
        string GetCurrentChildStateKey();

        /// <summary>
        /// å­çŠ¶æ…‹ã®ä¸€è¦§ã‚’å–å¾—ï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ï¼‰
        /// </summary>
        IReadOnlyDictionary<string, IState<TContext>> GetChildStates();

        /// <summary>
        /// æŒ‡å®šã•ã‚ŒãŸå­çŠ¶æ…‹ã¸ã®é·ç§»ãŒå¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
        /// </summary>
        bool CanTransitionToChild(string childStateKey, TContext context);

        /// <summary>
        /// ç›´å‰ã®å­çŠ¶æ…‹ã‚’å–å¾—
        /// </summary>
        string GetPreviousChildState();

        /// <summary>
        /// çŠ¶æ…‹å±¥æ­´ã‚’å–å¾—
        /// </summary>
        IReadOnlyCollection<string> GetStateHistory();
    }
}
```

### 3. StateDebugInfo ã‚¯ãƒ©ã‚¹

```csharp
namespace asterivo.Unity60.Core.StateMachine.Debug
{
    [System.Serializable]
    public class StateDebugInfo
    {
        [SerializeField] private List<StateTransitionRecord> transitionHistory;
        [SerializeField] private DateTime creationTime;
        [SerializeField] private int totalTransitions;
        [SerializeField] private string currentState;

        public StateDebugInfo()
        {
            transitionHistory = new List<StateTransitionRecord>();
            creationTime = DateTime.UtcNow;
            totalTransitions = 0;
        }

        public void RecordTransition(string transitionType, string details, DateTime timestamp)
        {
            var record = new StateTransitionRecord
            {
                TransitionType = transitionType,
                Details = details,
                Timestamp = timestamp,
                TransitionId = totalTransitions++
            };

            transitionHistory.Add(record);
            currentState = details;

            // å±¥æ­´ã‚µã‚¤ã‚ºåˆ¶é™ï¼ˆãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡åˆ¶å¾¡ï¼‰
            if (transitionHistory.Count > 100)
            {
                transitionHistory.RemoveAt(0);
            }
        }

        public IReadOnlyList<StateTransitionRecord> GetTransitionHistory()
        {
            return transitionHistory.AsReadOnly();
        }

        public TimeSpan GetUptime()
        {
            return DateTime.UtcNow - creationTime;
        }

        public int GetTotalTransitions() => totalTransitions;
        public string GetCurrentState() => currentState;
    }

    [System.Serializable]
    public class StateTransitionRecord
    {
        public string TransitionType;
        public string Details;
        public DateTime Timestamp;
        public int TransitionId;
    }
}
```

### 4. StateTransitionManager ã‚¯ãƒ©ã‚¹

```csharp
namespace asterivo.Unity60.Core.StateMachine
{
    public class StateTransitionManager<TContext>
    {
        private Dictionary<string, List<StateTransitionRule<TContext>>> transitionRules;
        private IState<TContext> currentState;
        private TContext context;

        public StateTransitionManager(TContext context)
        {
            this.context = context;
            transitionRules = new Dictionary<string, List<StateTransitionRule<TContext>>>();
        }

        public void AddTransitionRule(string fromState, string toState,
            System.Func<TContext, bool> condition, int priority = 0)
        {
            if (!transitionRules.ContainsKey(fromState))
            {
                transitionRules[fromState] = new List<StateTransitionRule<TContext>>();
            }

            var rule = new StateTransitionRule<TContext>
            {
                FromState = fromState,
                ToState = toState,
                Condition = condition,
                Priority = priority
            };

            transitionRules[fromState].Add(rule);

            // å„ªå…ˆåº¦é †ã§ã‚½ãƒ¼ãƒˆ
            transitionRules[fromState].Sort((a, b) => b.Priority.CompareTo(a.Priority));
        }

        public string EvaluateTransitions(string currentStateName)
        {
            if (!transitionRules.ContainsKey(currentStateName))
                return null;

            foreach (var rule in transitionRules[currentStateName])
            {
                if (rule.Condition(context))
                {
                    return rule.ToState;
                }
            }

            return null;
        }
    }

    public class StateTransitionRule<TContext>
    {
        public string FromState;
        public string ToState;
        public System.Func<TContext, bool> Condition;
        public int Priority;
    }
}
```

## Featureså±¤å®Ÿè£…ä¾‹

### 1. PlayerGroundedState å®Ÿè£…ä¾‹

```csharp
namespace asterivo.Unity60.Features.Player.StateMachine.Hierarchical
{
    public class PlayerGroundedState : HierarchicalState<PlayerContext>
    {
        protected override void InitializeChildStates()
        {
            // å­çŠ¶æ…‹ã®ç™»éŒ²
            AddChildState("Idle", new PlayerIdleState());
            AddChildState("Walk", new PlayerWalkState());
            AddChildState("Run", new PlayerRunState());
            AddChildState("Crouch", new PlayerCrouchState());

            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆçŠ¶æ…‹è¨­å®š
            defaultChildStateKey = GetDefaultChildStateKey();
        }

        protected override string GetDefaultChildStateKey()
        {
            return "Idle";
        }

        protected override void OnParentEnter(PlayerContext context)
        {
            // åœ°ä¸ŠçŠ¶æ…‹å›ºæœ‰ã®åˆæœŸåŒ–
            context.Player.SetGrounded(true);
            context.PhysicsController.EnableGroundedPhysics();

            // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªç’°å¢ƒè¨­å®š
            context.AudioManager.SetEnvironmentType(AudioEnvironmentType.Grounded);
        }

        protected override void OnParentUpdate(PlayerContext context)
        {
            // åœ°ä¸ŠçŠ¶æ…‹å…±é€šã®æ›´æ–°å‡¦ç†
            CheckGroundedStatus(context);
            HandleMovementInput(context);
        }

        protected override void OnParentExit(PlayerContext context)
        {
            // åœ°ä¸ŠçŠ¶æ…‹çµ‚äº†æ™‚ã®å‡¦ç†
            context.Player.SetGrounded(false);
        }

        protected override bool ValidateChildTransition(string childStateKey, PlayerContext context)
        {
            // å­çŠ¶æ…‹é·ç§»ã®æ¤œè¨¼ãƒ­ã‚¸ãƒƒã‚¯
            switch (childStateKey)
            {
                case "Run":
                    return context.InputManager.IsSprintPressed() && context.Player.HasStamina();
                case "Crouch":
                    return context.InputManager.IsCrouchPressed() && !context.Player.IsInCombat();
                default:
                    return true;
            }
        }

        private void CheckGroundedStatus(PlayerContext context)
        {
            if (!context.PhysicsController.IsGrounded())
            {
                // ç©ºä¸­çŠ¶æ…‹ã¸ã®é·ç§»ã‚’ãƒˆãƒªã‚¬ãƒ¼
                context.StateMachine.RequestTransition("Airborne");
            }
        }

        private void HandleMovementInput(PlayerContext context)
        {
            var input = context.InputManager.GetMovementInput();

            if (input.magnitude > 0.1f)
            {
                if (context.InputManager.IsSprintPressed() && context.Player.HasStamina())
                {
                    TransitionToChild("Run", context);
                }
                else
                {
                    TransitionToChild("Walk", context);
                }
            }
            else if (context.InputManager.IsCrouchPressed())
            {
                TransitionToChild("Crouch", context);
            }
            else
            {
                TransitionToChild("Idle", context);
            }
        }
    }
}
```

### 2. PlayerAirborneState å®Ÿè£…ä¾‹

```csharp
namespace asterivo.Unity60.Features.Player.StateMachine.Hierarchical
{
    public class PlayerAirborneState : HierarchicalState<PlayerContext>
    {
        protected override void InitializeChildStates()
        {
            AddChildState("Jump", new PlayerJumpState());
            AddChildState("Fall", new PlayerFallState());
            AddChildState("Glide", new PlayerGlideState());

            defaultChildStateKey = GetDefaultChildStateKey();
        }

        protected override string GetDefaultChildStateKey()
        {
            return "Fall";
        }

        protected override void OnParentEnter(PlayerContext context)
        {
            context.Player.SetGrounded(false);
            context.PhysicsController.EnableAirbornePhysics();
            context.AudioManager.SetEnvironmentType(AudioEnvironmentType.Airborne);

            // å…¥åŠ›ã•ã‚ŒãŸæ™‚ç‚¹ã§ã®çŠ¶æ…‹ã§å­çŠ¶æ…‹ã‚’æ±ºå®š
            if (context.PhysicsController.GetVerticalVelocity() > 0)
            {
                TransitionToChild("Jump", context);
            }
            else
            {
                TransitionToChild("Fall", context);
            }
        }

        protected override void OnParentUpdate(PlayerContext context)
        {
            CheckLandingStatus(context);
            HandleAirMovement(context);
        }

        private void CheckLandingStatus(PlayerContext context)
        {
            if (context.PhysicsController.IsGrounded())
            {
                context.StateMachine.RequestTransition("Grounded");
            }
        }

        private void HandleAirMovement(PlayerContext context)
        {
            var verticalVelocity = context.PhysicsController.GetVerticalVelocity();

            if (verticalVelocity > 0.5f && GetCurrentChildStateKey() != "Jump")
            {
                TransitionToChild("Jump", context);
            }
            else if (verticalVelocity < -0.5f && GetCurrentChildStateKey() != "Fall")
            {
                if (context.InputManager.IsGlidePressed() && context.Player.CanGlide())
                {
                    TransitionToChild("Glide", context);
                }
                else
                {
                    TransitionToChild("Fall", context);
                }
            }
        }
    }
}
```

## ã‚¨ãƒ‡ã‚£ã‚¿æ‹¡å¼µãƒ»ãƒ‡ãƒãƒƒã‚°æ”¯æ´

### 1. HierarchicalStateInspector

```csharp
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace asterivo.Unity60.Core.StateMachine.Editor
{
    [CustomPropertyDrawer(typeof(HierarchicalState<>))]
    public class HierarchicalStateInspector : PropertyDrawer
    {
        public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
        {
            EditorGUI.BeginProperty(position, label, property);

            // éšå±¤çŠ¶æ…‹ã®è¦–è¦šçš„è¡¨ç¤º
            var hierarchicalState = GetHierarchicalState(property);
            if (hierarchicalState != null)
            {
                DrawStateHierarchy(position, hierarchicalState);
            }

            EditorGUI.EndProperty();
        }

        private void DrawStateHierarchy(Rect position, object hierarchicalState)
        {
            // ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã—ã¦éšå±¤æ§‹é€ ã‚’æç”»
            var currentChildStateKey = GetCurrentChildStateKey(hierarchicalState);
            var childStates = GetChildStates(hierarchicalState);

            EditorGUI.LabelField(position, $"Current Child: {currentChildStateKey ?? "None"}");

            position.y += EditorGUIUtility.singleLineHeight;

            foreach (var childState in childStates)
            {
                var isActive = childState.Key == currentChildStateKey;
                var style = isActive ? EditorStyles.boldLabel : EditorStyles.label;

                EditorGUI.LabelField(position, $"  {childState.Key}", style);
                position.y += EditorGUIUtility.singleLineHeight;
            }
        }

        // ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
        private object GetHierarchicalState(SerializedProperty property) { /* å®Ÿè£… */ }
        private string GetCurrentChildStateKey(object state) { /* å®Ÿè£… */ }
        private System.Collections.IDictionary GetChildStates(object state) { /* å®Ÿè£… */ }
    }
}
#endif
```

### 2. StateHierarchyDebugWindow

```csharp
#if UNITY_EDITOR
using UnityEditor;
using UnityEngine;

namespace asterivo.Unity60.Core.StateMachine.Editor
{
    public class StateHierarchyDebugWindow : EditorWindow
    {
        private Vector2 scrollPosition;
        private GameObject selectedGameObject;
        private MonoBehaviour[] stateMachines;

        [MenuItem("Tools/State Machine/Hierarchy Debugger")]
        public static void ShowWindow()
        {
            GetWindow<StateHierarchyDebugWindow>("State Hierarchy Debugger");
        }

        private void OnGUI()
        {
            DrawHeader();
            DrawGameObjectSelection();

            if (selectedGameObject != null)
            {
                DrawStateMachineList();
                DrawStateHierarchy();
            }
        }

        private void DrawHeader()
        {
            EditorGUILayout.LabelField("Hierarchical State Machine Debugger", EditorStyles.boldLabel);
            EditorGUILayout.Space();
        }

        private void DrawGameObjectSelection()
        {
            var newSelection = EditorGUILayout.ObjectField("Target GameObject",
                selectedGameObject, typeof(GameObject), true) as GameObject;

            if (newSelection != selectedGameObject)
            {
                selectedGameObject = newSelection;
                RefreshStateMachines();
            }
        }

        private void DrawStateMachineList()
        {
            if (stateMachines == null || stateMachines.Length == 0)
            {
                EditorGUILayout.HelpBox("No state machines found on this GameObject.", MessageType.Info);
                return;
            }

            foreach (var stateMachine in stateMachines)
            {
                if (stateMachine == null) continue;

                EditorGUILayout.BeginVertical("box");
                EditorGUILayout.LabelField(stateMachine.GetType().Name, EditorStyles.boldLabel);

                // éšå±¤çŠ¶æ…‹ã®è¡¨ç¤º
                DrawStateMachineHierarchy(stateMachine);

                EditorGUILayout.EndVertical();
                EditorGUILayout.Space();
            }
        }

        private void DrawStateHierarchy()
        {
            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition);

            // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°ã®ãŸã‚ã® Repaint
            if (Application.isPlaying)
            {
                Repaint();
            }

            EditorGUILayout.EndScrollView();
        }

        private void RefreshStateMachines()
        {
            if (selectedGameObject == null)
            {
                stateMachines = null;
                return;
            }

            // StateMachineç³»ã®ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆã‚’æ¤œç´¢
            stateMachines = selectedGameObject.GetComponents<MonoBehaviour>();
        }

        private void DrawStateMachineHierarchy(MonoBehaviour stateMachine)
        {
            // ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’ä½¿ç”¨ã—ã¦HierarchicalStateã‚’æ¤œå‡ºãƒ»è¡¨ç¤º
            var fields = stateMachine.GetType().GetFields(System.Reflection.BindingFlags.Public |
                System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance);

            foreach (var field in fields)
            {
                if (IsHierarchicalStateField(field))
                {
                    var hierarchicalState = field.GetValue(stateMachine);
                    if (hierarchicalState != null)
                    {
                        DrawHierarchicalStateInfo(field.Name, hierarchicalState);
                    }
                }
            }
        }

        private bool IsHierarchicalStateField(System.Reflection.FieldInfo field)
        {
            return field.FieldType.IsGenericType &&
                   field.FieldType.GetGenericTypeDefinition() == typeof(HierarchicalState<>);
        }

        private void DrawHierarchicalStateInfo(string fieldName, object hierarchicalState)
        {
            EditorGUILayout.LabelField($"  {fieldName}:", EditorStyles.boldLabel);

            // ç¾åœ¨ã®å­çŠ¶æ…‹ã‚’è¡¨ç¤º
            var currentChild = GetCurrentChildStateKey(hierarchicalState);
            EditorGUILayout.LabelField($"    Current Child: {currentChild ?? "None"}");

            // å­çŠ¶æ…‹ä¸€è¦§ã‚’è¡¨ç¤º
            var childStates = GetChildStates(hierarchicalState);
            foreach (var kvp in childStates)
            {
                var isActive = kvp.Key == currentChild;
                var style = isActive ? EditorStyles.boldLabel : EditorStyles.label;
                var color = isActive ? Color.green : Color.gray;

                var originalColor = GUI.color;
                GUI.color = color;
                EditorGUILayout.LabelField($"      â€¢ {kvp.Key}", style);
                GUI.color = originalColor;
            }
        }

        // ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ï¼ˆå®Ÿè£…çœç•¥ï¼‰
        private string GetCurrentChildStateKey(object hierarchicalState) { return ""; }
        private System.Collections.IDictionary GetChildStates(object hierarchicalState) { return new System.Collections.Hashtable(); }
    }
}
#endif
```

## ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¦ä»¶ãƒ»æœ€é©åŒ–

### 1. ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡æœ€é©åŒ–
- **Dictionaryä½¿ç”¨**: O(1)ã®é«˜é€ŸçŠ¶æ…‹æ¤œç´¢
- **å±¥æ­´ã‚µã‚¤ã‚ºåˆ¶é™**: ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯é˜²æ­¢ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ10ä»¶ï¼‰
- **ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«**: çŠ¶æ…‹ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å†åˆ©ç”¨

### 2. CPUæ€§èƒ½æœ€é©åŒ–
- **ã‚­ãƒ£ãƒƒã‚·ãƒ¥æ´»ç”¨**: é »ç¹ã«ã‚¢ã‚¯ã‚»ã‚¹ã•ã‚Œã‚‹çŠ¶æ…‹æƒ…å ±ã®ã‚­ãƒ£ãƒƒã‚·ãƒ¥
- **æ¡ä»¶åˆ†å²æœ€å°åŒ–**: çŠ¶æ…‹é·ç§»åˆ¤å®šã®åŠ¹ç‡åŒ–
- **ãƒªãƒ•ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³å›é¿**: å®Ÿè¡Œæ™‚ã®å‹æƒ…å ±å–å¾—æœ€å°åŒ–

### 3. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
```csharp
namespace asterivo.Unity60.Core.StateMachine.Performance
{
    public class StatePerformanceProfiler
    {
        private Dictionary<string, StatePerformanceMetrics> metrics;

        public void RecordStateTransition(string stateName, float executionTime)
        {
            if (!metrics.ContainsKey(stateName))
            {
                metrics[stateName] = new StatePerformanceMetrics();
            }

            metrics[stateName].RecordExecution(executionTime);
        }

        public StatePerformanceReport GenerateReport()
        {
            return new StatePerformanceReport(metrics);
        }
    }

    public class StatePerformanceMetrics
    {
        public float TotalExecutionTime { get; private set; }
        public int ExecutionCount { get; private set; }
        public float AverageExecutionTime => ExecutionCount > 0 ? TotalExecutionTime / ExecutionCount : 0;

        public void RecordExecution(float executionTime)
        {
            TotalExecutionTime += executionTime;
            ExecutionCount++;
        }
    }
}
```

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### 1. å˜ä½“ãƒ†ã‚¹ãƒˆ
```csharp
namespace asterivo.Unity60.Tests.Core.StateMachine
{
    [TestFixture]
    public class HierarchicalStateTests
    {
        private TestHierarchicalState hierarchicalState;
        private TestContext context;

        [SetUp]
        public void Setup()
        {
            hierarchicalState = new TestHierarchicalState();
            context = new TestContext();
        }

        [Test]
        public void Enter_ShouldTransitionToDefaultChildState()
        {
            // Arrange & Act
            hierarchicalState.Enter(context);

            // Assert
            Assert.AreEqual("DefaultChild", hierarchicalState.GetCurrentChildStateKey());
        }

        [Test]
        public void TransitionToChild_WithValidState_ShouldSucceed()
        {
            // Arrange
            hierarchicalState.Enter(context);

            // Act
            hierarchicalState.TransitionToChild("TestChild", context);

            // Assert
            Assert.AreEqual("TestChild", hierarchicalState.GetCurrentChildStateKey());
        }

        [Test]
        public void TransitionToChild_WithInvalidState_ShouldLogError()
        {
            // ãƒ†ã‚¹ãƒˆå®Ÿè£…
        }
    }
}
```

### 2. çµ±åˆãƒ†ã‚¹ãƒˆ
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼çŠ¶æ…‹é·ç§»ã®å®Ÿéš›ã®ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã§ã®æ¤œè¨¼
- AIçŠ¶æ…‹ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ ã®çµ±åˆãƒ†ã‚¹ãƒˆ
- ã‚«ãƒ¡ãƒ©çŠ¶æ…‹ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼è¡Œå‹•ã®åŒæœŸãƒ†ã‚¹ãƒˆ

### 3. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
- å¤§é‡ã®çŠ¶æ…‹é·ç§»æ™‚ã®ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡æ¸¬å®š
- ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆã¸ã®å½±éŸ¿åº¦æ¸¬å®š
- çŠ¶æ…‹å±¥æ­´è“„ç©æ™‚ã®ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ¤œè¨¼

## å®Ÿè£…æ‰‹é †ãƒ»ãƒ•ã‚§ãƒ¼ã‚º

### Phase 1: Coreå±¤åŸºç›¤å®Ÿè£…ï¼ˆ2-3æ—¥ï¼‰
1. **Day 1**: IHierarchicalState<T>ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã€HierarchicalState<T>åŸºåº•ã‚¯ãƒ©ã‚¹
2. **Day 2**: StateTransitionManagerã€StateDebugInfo
3. **Day 3**: ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã€å˜ä½“ãƒ†ã‚¹ãƒˆ

### Phase 2: Featureså±¤æ´»ç”¨ä¾‹å®Ÿè£…ï¼ˆ1-2æ—¥ï¼‰
1. **Day 1**: PlayerGroundedStateã€PlayerAirborneStateå®Ÿè£…
2. **Day 2**: AIãƒ»CameraçŠ¶æ…‹ã¸ã®é©ç”¨ã€çµ±åˆãƒ†ã‚¹ãƒˆ

### Phase 3: ã‚¨ãƒ‡ã‚£ã‚¿æ‹¡å¼µãƒ»ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ï¼ˆ1æ—¥ï¼‰
1. **Custom Inspector**: HierarchicalStateInspector
2. **Debug Window**: StateHierarchyDebugWindow

### Phase 4: ãƒ†ã‚¹ãƒˆãƒ»æ¤œè¨¼ï¼ˆ1æ—¥ï¼‰
1. **çµ±åˆãƒ†ã‚¹ãƒˆ**: å…¨ã‚·ã‚¹ãƒ†ãƒ é€£æºç¢ºèª
2. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ**: æ€§èƒ½è¦ä»¶é”æˆç¢ºèª

## ãƒ•ã‚¡ã‚¤ãƒ«ãƒ»ãƒ•ã‚©ãƒ«ãƒ€æ§‹æˆ

```
Assets/_Project/Core/StateMachine/
â”œâ”€â”€ Interfaces/
â”‚   â”œâ”€â”€ IHierarchicalState.cs
â”‚   â””â”€â”€ IStateTransitionRule.cs
â”œâ”€â”€ HierarchicalState.cs
â”œâ”€â”€ StateTransitionManager.cs
â””â”€â”€ Debug/
    â”œâ”€â”€ StateDebugInfo.cs
    â”œâ”€â”€ StatePerformanceProfiler.cs
    â””â”€â”€ Editor/
        â”œâ”€â”€ HierarchicalStateInspector.cs
        â””â”€â”€ StateHierarchyDebugWindow.cs

Assets/_Project/Features/Player/StateMachine/Hierarchical/
â”œâ”€â”€ PlayerGroundedState.cs
â”œâ”€â”€ PlayerAirborneState.cs
â””â”€â”€ States/
    â”œâ”€â”€ PlayerIdleState.cs
    â”œâ”€â”€ PlayerWalkState.cs
    â”œâ”€â”€ PlayerRunState.cs
    â””â”€â”€ PlayerJumpState.cs

Assets/_Project/Features/AI/StateMachine/Hierarchical/
â”œâ”€â”€ AICombatState.cs
â”œâ”€â”€ AIAlertState.cs
â””â”€â”€ States/
    â”œâ”€â”€ AIMeleeState.cs
    â”œâ”€â”€ AIRangedState.cs
    â””â”€â”€ AIDefensiveState.cs

Assets/_Project/Features/Camera/StateMachine/Hierarchical/
â”œâ”€â”€ ThirdPersonState.cs
â””â”€â”€ States/
    â”œâ”€â”€ NormalCameraState.cs
    â”œâ”€â”€ CombatCameraState.cs
    â””â”€â”€ ExplorationCameraState.cs

Assets/_Project/Tests/Core/StateMachine/
â”œâ”€â”€ HierarchicalStateTests.cs
â”œâ”€â”€ StateTransitionManagerTests.cs
â””â”€â”€ Integration/
    â”œâ”€â”€ PlayerStateMachineIntegrationTests.cs
    â””â”€â”€ AIStateMachineIntegrationTests.cs
```

## ãƒªã‚¹ã‚¯ãƒ»åˆ¶é™äº‹é …

### æŠ€è¡“çš„ãƒªã‚¹ã‚¯
1. **è¤‡é›‘æ€§å¢—åŠ **: éåº¦ã®éšå±¤åŒ–ã«ã‚ˆã‚‹ç†è§£å›°é›£
2. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**: æ·±ã„éšå±¤ã§ã®æ€§èƒ½åŠ£åŒ–
3. **ãƒ‡ãƒãƒƒã‚°é›£åº¦**: éšå±¤çŠ¶æ…‹ã®ãƒ‡ãƒãƒƒã‚°è¤‡é›‘åŒ–

### è»½æ¸›ç­–
1. **æ®µéšçš„å°å…¥**: å¿…è¦ãªç®‡æ‰€ã‹ã‚‰æ®µéšçš„é©ç”¨
2. **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–**: ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ€§èƒ½æ¸¬å®š
3. **ãƒ‡ãƒãƒƒã‚°æ”¯æ´å¼·åŒ–**: å°‚ç”¨ã‚¨ãƒ‡ã‚£ã‚¿ãƒ„ãƒ¼ãƒ«å……å®Ÿ

### åˆ¶é™äº‹é …
1. **æœ€å¤§éšå±¤æ·±åº¦**: æ¨å¥¨3éšå±¤ã¾ã§ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®ï¼‰
2. **ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡**: å±¥æ­´ç®¡ç†ã«ã‚ˆã‚‹è¿½åŠ ãƒ¡ãƒ¢ãƒªæ¶ˆè²»
3. **å­¦ç¿’ã‚³ã‚¹ãƒˆ**: æ–°ã—ã„æ¦‚å¿µç¿’å¾—ã®å¿…è¦æ€§

## æˆåŠŸåŸºæº–ãƒ»å®Œäº†æ¡ä»¶

### æ©Ÿèƒ½è¦ä»¶
- âœ… HierarchicalState<T>åŸºåº•ã‚¯ãƒ©ã‚¹ã®å®Œå…¨å®Ÿè£…
- âœ… Playeréšå±¤åŒ–ï¼ˆGrounded/Airborneï¼‰ã®å‹•ä½œç¢ºèª
- âœ… ãƒ‡ãƒãƒƒã‚°ãƒ„ãƒ¼ãƒ«ã«ã‚ˆã‚‹éšå±¤çŠ¶æ…‹å¯è¦–åŒ–

### æ€§èƒ½è¦ä»¶
- âœ… çŠ¶æ…‹é·ç§»å‡¦ç†æ™‚é–“: 1msä»¥ä¸‹

---

## å®Ÿè£…å®Œäº†ã‚µãƒãƒªãƒ¼ï¼ˆ2025å¹´9æœˆ19æ—¥ï¼‰

### âœ… Phase 1: Coreéšå±¤åŒ–ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³åŸºç›¤
**å®Ÿè£…å®Œäº†é …ç›®**:
- `HierarchicalState<T>` æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹
- `IHierarchicalState<T>` ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
- `StateTransitionManager` é·ç§»ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 
- `StateDebugInfo` ãƒ‡ãƒãƒƒã‚°æƒ…å ±ç®¡ç†

**é…ç½®å ´æ‰€**: `Assets/_Project/Core/Patterns/StateMachine/`

### âœ… Phase 2: Featureå±¤å®Ÿè£…ä¾‹
**Playerå±¤å®Ÿè£…**:
- `PlayerGroundedState` (Idle, Walk, Run, Crouchå­çŠ¶æ…‹)
- `PlayerAirborneState` (Jump, Fall, Glideå­çŠ¶æ…‹)
- `PlayerContext` ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†

**AIå±¤å®Ÿè£…**:
- `AIPatrolState` (Walking, Waitingå­çŠ¶æ…‹)
- `AIAlertState` (Combat, Searchingå­çŠ¶æ…‹)
- `HierarchicalAIStateMachine` çµ±åˆç®¡ç†
- `AIContext` ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†

**Cameraå±¤å®Ÿè£…**:
- `ThirdPersonCameraState` (Follow, FreeLookå­çŠ¶æ…‹)
- `AimCameraState` (Quick, Preciseå­çŠ¶æ…‹)
- `HierarchicalCameraStateMachine` çµ±åˆç®¡ç†
- `CameraContext` ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆç®¡ç†

**é…ç½®å ´æ‰€**: `Assets/_Project/Features/{Player,AI,Camera}/StateMachine/`

### âœ… Phase 3: ã‚¨ãƒ‡ã‚£ã‚¿æ‹¡å¼µãƒ»ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½
**ã‚¨ãƒ‡ã‚£ã‚¿ãƒ„ãƒ¼ãƒ«**:
- `HierarchicalStateInspector` Inspectoræ‹¡å¼µ
- `StateHierarchyDebugWindow` ãƒ‡ãƒãƒƒã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ çŠ¶æ…‹ç›£è¦–ãƒ»å±¥æ­´è¡¨ç¤ºãƒ»é·ç§»å¯è¦–åŒ–

**çµ±åˆãƒ‡ãƒ¢**:
- `HierarchicalStateMachineDemo` çµ±åˆãƒ†ã‚¹ãƒˆã‚·ãƒ¼ãƒ³
- Player/AI/Cameraéšå±¤åŒ–ã‚¹ãƒ†ãƒ¼ãƒˆã®å‹•ä½œç¢ºèª
- è‡ªå‹•ãƒ‡ãƒ¢ãƒ»æ‰‹å‹•æ“ä½œãƒ»ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½

**é…ç½®å ´æ‰€**: `Assets/_Project/Core/Patterns/StateMachine/Editor/`

### ğŸ¯ å®Ÿè£…æˆæœ
- **å®Œå…¨ãªCore/Featuresåˆ†é›¢**: å†åˆ©ç”¨å¯èƒ½ãªåŸºç›¤ã‚·ã‚¹ãƒ†ãƒ æ§‹ç¯‰å®Œäº†
- **3ã‚·ã‚¹ãƒ†ãƒ çµ±åˆ**: Playerã€AIã€Cameraã§ã®éšå±¤åŒ–ã‚¹ãƒ†ãƒ¼ãƒˆæ´»ç”¨å®Ÿç¾
- **é–‹ç™ºåŠ¹ç‡å‘ä¸Š**: ã‚¨ãƒ‡ã‚£ã‚¿æ‹¡å¼µã«ã‚ˆã‚‹å¯è¦–åŒ–ãƒ»ãƒ‡ãƒãƒƒã‚°æ”¯æ´å®Œå‚™
- **è¨­è¨ˆæ›¸ã¨ã®æ•´åˆæ€§**: è¨­è¨ˆä»•æ§˜100%å®Ÿè£…é”æˆ

### ğŸ“‹ æ¬¡æœŸå±•é–‹å¯èƒ½æ€§
- **æ–°ã‚¸ãƒ£ãƒ³ãƒ«å¯¾å¿œ**: Action RPGã€Survival Horrorç­‰ã¸ã®é©ç”¨æº–å‚™å®Œäº†
- **æ€§èƒ½æœ€é©åŒ–**: ObjectPoolçµ±åˆã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ 
- **ãƒ†ã‚¹ãƒˆè‡ªå‹•åŒ–**: å˜ä½“ãƒ»çµ±åˆãƒ†ã‚¹ãƒˆãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯æ§‹ç¯‰
- **ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆç”Ÿæˆ**: è‡ªå‹•APIæ–‡æ›¸ç”Ÿæˆã‚·ã‚¹ãƒ†ãƒ 

**Phase 3å®Ÿè£…å®Œäº†: 2025å¹´9æœˆ19æ—¥**
- âœ… ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡: å¾“æ¥æ¯”120%ä»¥å†…
- âœ… ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆå½±éŸ¿: 1%ä»¥å†…

### å“è³ªè¦ä»¶
- âœ… å˜ä½“ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸: 80%ä»¥ä¸Š
- âœ… çµ±åˆãƒ†ã‚¹ãƒˆ: å…¨ã‚·ãƒŠãƒªã‚ªãƒ‘ã‚¹
- âœ… ã‚³ãƒ¼ãƒ‰å“è³ª: æ—¢å­˜å“è³ªåŸºæº–æº–æ‹ 

## ç¶™ç¶šçš„æ”¹å–„ãƒ»æ‹¡å¼µè¨ˆç”»

### çŸ­æœŸï¼ˆ1-2ãƒ¶æœˆï¼‰
- ä»–ã‚²ãƒ¼ãƒ ã‚¸ãƒ£ãƒ³ãƒ«ã¸ã®é©ç”¨ç¯„å›²æ‹¡å¤§
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã®ç¶™ç¶šå®Ÿæ–½
- ãƒ‡ãƒãƒƒã‚°ãƒ„ãƒ¼ãƒ«ã®æ©Ÿèƒ½å¼·åŒ–

### ä¸­æœŸï¼ˆ3-6ãƒ¶æœˆï¼‰
- ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒ†ã‚£ãƒ³ã‚°çµ±åˆ
- AIå­¦ç¿’ã‚·ã‚¹ãƒ†ãƒ ã¨ã®é€£æº
- çŠ¶æ…‹é·ç§»ã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³çµ±åˆ

### é•·æœŸï¼ˆ6ãƒ¶æœˆä»¥ä¸Šï¼‰
- ML.Agentsã¨ã®çµ±åˆå¯èƒ½æ€§æ¤œè¨
- çŠ¶æ…‹ã‚·ã‚¹ãƒ†ãƒ ã®è‡ªå‹•æœ€é©åŒ–æ©Ÿèƒ½
- ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£å‘ã‘ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆå…¬é–‹

---

## çµè«–

ã“ã®è©³ç´°è¨­è¨ˆæ›¸ã«ã‚ˆã‚Šã€éšå±¤åŒ–ã‚¹ãƒ†ãƒ¼ãƒˆãƒã‚·ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã®æŠ€è¡“çš„å®Ÿè£…ãŒå®Œå…¨ã«å¯èƒ½ã¨ãªã‚Šã¾ã™ã€‚Core/Featuresåˆ†é›¢åŸå‰‡ã«å®Œå…¨æº–æ‹ ã—ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ—¢å­˜ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¨æ•´åˆæ€§ã‚’ä¿ã¡ãªãŒã‚‰ã€**å†åˆ©ç”¨æ€§ãƒ»ä¿å®ˆæ€§ãƒ»æ‹¡å¼µæ€§**ã®å¤§å¹…å‘ä¸Šã‚’å®Ÿç¾ã—ã¾ã™ã€‚

æ¨å®šå®Ÿè£…æœŸé–“: **5-7æ—¥**ã§ã€ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ä¾¡å€¤å‘ä¸Šã«ç›´æ¥çš„ã«è²¢çŒ®ã™ã‚‹å„ªã‚ŒãŸæ©Ÿèƒ½è¿½åŠ ã¨ãªã‚‹ã“ã¨ã‚’ç¢ºä¿¡ã—ã¾ã™ã€‚