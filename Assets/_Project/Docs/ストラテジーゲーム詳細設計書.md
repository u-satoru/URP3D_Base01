

# **3Dストラテジーゲーム 詳細設計書**

## **1\. はじめに**

本ドキュメントは、「3Dストラテジーゲーム要件定義書」で定義されたビジョンと要件を実現するための、技術的な詳細設計を定義するものです。設計の根幹には、**保守性**、**拡張性**、そしてリアルタイムストラテジー（RTS）に不可欠な**パフォーマンス**の3つの柱を据えます。

これを達成するため、以下の設計思想を採用します。

* **データ指向設計**: パフォーマンスを最大化するため、Entity Component System (ECS) アーキテクチャを中核に採用します 1。  
* **疎結合**: システム間の依存関係を最小限に抑え、モジュール性とテスト容易性を高めるため、Service Locatorパターンを積極的に活用します 3。  
* **再利用性**: 実証済みのデザインパターン（Abstract Factory, Strategy, Stateなど）を適切に適用し、堅牢で再利用可能なコードベースを構築します 5。

## **2\. アーキテクチャ概要**

本作は、**Entity Component System (ECS) アーキテクチャ**を基盤とします。ECSは、多数のオブジェクト（ユニット、建造物、弾丸など）が動的に相互作用するRTSゲームにおいて、優れたパフォーマンスを発揮します 7。

アーキテクチャは、大きく3つのレイヤーで構成されます。

1. **エンジン/フレームワーク層**: ゲームエンジン（例: Unity, Unreal Engine）が提供する低レベル機能。  
2. **コアシステム層**: ゲームの基盤となるシステム群。ECS基盤、グローバルサービス（Service Locator経由で提供）、データ管理などが含まれます。  
3. **ゲームプレイ層**: ゲームの具体的なロジックを実装するECSのシステム（System）とコンポーネント（Component）群。

\!(https://i.imgur.com/example.png)  
(図1: 全体アーキテクチャ図 \- 概念図)

## **3\. グローバルサービス設計 (Service Locatorパターン)**

システム間の疎結合を実現するため、ゲーム全体で共有される機能は「サービス」として提供し、**Service Locatorパターン**を用いてアクセスします 4。これにより、各システムは具体的な実装クラスを知ることなく、インターフェースを通じて必要なサービスを利用できます。

### **3.1. ServiceLocatorクラス**

ServiceLocatorは、すべてのグローバルサービスへのアクセスを提供する静的なラッパーです。ゲーム起動時にすべてのサービスを初期化し、登録します。

C\#

// ServiceLocatorの実装例  
public static class ServiceLocator  
{  
    private static readonly Dictionary\<Type, object\> \_services \= new Dictionary\<Type, object\>();

    public static void Register\<T\>(T service)  
    {  
        \_services \= service;  
    }

    public static T Get\<T\>()  
    {  
        try  
        {  
            return (T)\_services;  
        }  
        catch (KeyNotFoundException)  
        {  
            throw new ApplicationException($"{typeof(T)} is not registered.");  
        }  
    }

    public static void InitializeServices()  
    {  
        // ゲーム起動時にすべてのサービスを登録  
        Register\<IGameEventManager\>(new GameEventManager());  
        Register\<IInputManager\>(new InputManager());  
        Register\<IPathfindingService\>(new AStarPathfindingService());  
        Register\<IDataManager\>(new DataManager());  
        // 他のサービス...  
    }  
}

3

### **3.2. 主要サービスインターフェース**

Service Locatorを通じて提供される主要なサービスは以下の通りです。

* IGameEventManager: ゲーム内イベントの発行と購読を管理する（Observerパターン）。  
* IInputManager: プレイヤーの入力を抽象化し、ゲーム内コマンドに変換する。  
* IPathfindingService: ユニットの経路探索を担当する（A\*アルゴリズム） 10。  
* IDataManager: ユニットや勢力のデータを外部ファイルからロード・管理する。  
* IUIManager: UI要素の生成と状態管理を行う。  
* IAIManager: AIプレイヤーの戦略的意思決定を行う。

## **4\. コアゲームプレイシステムの詳細設計**

ゲームプレイロジックはECSアーキテクチャに基づいて実装されます。

### **4.1. Entity Component System (ECS) 基盤**

* **Entity**: ゲーム世界のすべてのオブジェクト（ユニット、建物、資源ノード等）を表す一意のID 2。  
* **Component**: オブジェクトの「データ」を保持する構造体。ロジックは含まない（例: PositionComponent, HealthComponent, AttackComponent） 2。  
* **System**: 特定のComponentを持つEntity群を処理する「ロジック」。毎フレーム実行される（例: MovementSystem, CombatSystem） 8。

### **4.2. 経済エンジン (資源管理)**

要件定義書の「3.1. 経済エンジン」に対応します。

* **関連コンポーネント**:  
  * ResourceSourceComponent: 資源の種類、埋蔵量。  
  * WorkerComponent: 資源の収集速度、運搬容量。  
  * CarryingResourceComponent: ワーカーが運搬中の資源情報。  
* **関連システム**:  
  * ResourceGatheringSystem: WorkerComponentを持つEntityが範囲内のResourceSourceComponentから資源を収集するロジック。  
  * ResourceDropOffSystem: 資源を運搬中のワーカーが納入施設に到達した際に、プレイヤーの資源に加算するロジック。  
* **関連サービス**:  
  * PlayerResourceManager (各プレイヤーが所持): プレイヤーごとの資源（ゴールド、エーテル、影響力）を管理する。

### **4.3. 帝国建設 (建造と生産)**

要件定義書の「3.2. 帝国の建設」と、非対称な勢力設計を実現します。

* Abstract Factory パターン:  
  勢力ごとに異なるユニットや建物を生成するため、Abstract Factoryパターンを採用します 11。  
  * IFactionFactory (インターフェース): CreateInfantry(), CreateCavalry(), CreateBarracks()などのメソッドを定義。  
  * HumanFactionFactory, DemonFactionFactory (具象クラス): 各勢力固有のユニット/建物のEntityを生成するロジックを実装。生成するEntityには、勢力固有のComponentが付与されます。

C\#

// Abstract Factory の利用例  
public class UnitProductionSystem : ISystem  
{  
    public void Update()  
    {  
        //... 生産キューを持つ建物を探す...  
        var factionType \= buildingEntity.GetComponent\<FactionComponent\>().Type;  
        IFactionFactory factory \= ServiceLocator.Get\<IDataManager\>().GetFactionFactory(factionType);  
          
        Entity newUnit \= factory.CreateInfantry();  
        //... ユニットをマップ上に出現させる...  
    }  
}

12

* **関連コンポーネント**:  
  * BuilderComponent: 建設能力を持つユニット（ワーカーなど）。  
  * ConstructibleComponent: 建設中の建物の進捗状況。  
  * ProductionQueueComponent: ユニット生産施設が持つ生産キュー。  
* **関連システム**:  
  * ConstructionSystem: BuilderComponentを持つユニットがConstructibleComponentを持つ建物を建設するロジック。  
  * UnitProductionSystem: ProductionQueueComponentを持つ建物からユニットを生産するロジック。

### **4.4. 技術と進行システム**

要件定義書の「3.3. 力への道」に対応します。

* Strategy パターン:  
  技術研究によって得られる効果（例: 「歩兵の攻撃力+10%」）は多岐にわたるため、Strategyパターンを用いて効果の適用ロジックをカプセル化します 13。  
  * IEffectStrategy (インターフェース): ApplyEffect(Entity target)メソッドを定義。  
  * IncreaseAttackDamageStrategy, IncreaseGatherRateStrategy (具象クラス): 具体的な効果を適用するロジックを実装。  
* **関連サービス**:  
  * TechnologyManager (各プレイヤーが所持): プレイヤーの技術ツリーの状態と、研究可能な技術を管理する。  
* **関連システム**:  
  * ResearchSystem: プレイヤーが選択した技術の研究を進捗させる。研究完了時、対応するIEffectStrategyを実行する。

### **4.5. 戦闘とユニット**

要件定義書の「第IV部 戦争の技術」に対応します。

* ユニットのコンポーネント構成:  
  ユニットはComponentの集合体として定義されます。  
  * 例: 槍兵Entity \= Position, Health, Movement, Attack, Armor, Faction, Selectable, AntiCavalryBonusComponent  
* State パターン:  
  ユニットの複雑な状態（待機、移動、攻撃、スキル使用中など）を管理するため、Stateパターンを導入します 15。  
  * IUnitState (インターフェース): OnEnter(), OnUpdate(), OnExit()メソッドを定義。  
  * IdleState, MovingState, AttackingState (具象クラス): 各状態での振る舞いを実装。  
* CombatSystem:  
  攻撃範囲内に敵がいるAttackComponentを持つEntityの戦闘ロジックを処理します。ダメージ計算式は、攻撃力、防御力、そしてユニット間の相性（例: AntiCavalryBonusComponent）を考慮します。  
* **PathfindingとMovement**:  
  * IPathfindingService: Service Locator経由で提供。3D空間の地形（高低差、通行不可エリア）を考慮した**A\*アルゴリズム**を実装し、最適な経路を計算します 10。  
  * MovementSystem: MovementComponentと目標地点を持つEntityに対し、IPathfindingServiceに経路を問い合わせ、経路に沿ってPositionComponentを更新します。

## **5\. UI/UXシステム設計**

要件定義書の「5.3. 指揮と統制」に対応します。「判読可能な複雑性」を実現するため、ゲームロジックとUIを明確に分離します。

* MVVM (Model-View-ViewModel) パターン:  
  UIの状態とロジックを管理するためにMVVMパターンを採用します。  
  * **Model**: ゲームの状態そのもの（例: PlayerResourceManager、EntityのHealthComponent）。  
  * **View**: 画面に表示されるUI要素（UnityのUIコンポーネントなど）。  
  * **ViewModel**: ViewとModelを仲介。Modelからデータを取得し、Viewが表示しやすい形式に変換・保持する。Viewからの入力を受け取り、IInputManager経由でコマンドを発行する。  
* Observer パターン:  
  IGameEventManagerサービスを利用して、ゲーム内イベント（例: OnResourceChanged, OnUnitSelected, OnBuildingCompleted）をViewModelに通知します。ViewModelはイベントを受け取ると自身のプロパティを更新し、データバインディングを通じてViewが自動的に更新されます。

## **6\. データ管理**

非対称な勢力設計を柔軟かつ拡張可能にするため、ユニット、建物、技術などのゲームデータは外部ファイル（JSONまたはScriptableObject）で管理します。

* IDataManager (Service):  
  ゲーム起動時にすべての設定ファイルをロードし、ゲーム内で利用可能な形式でキャッシュします。IFactionFactoryの具象クラスも、このIDataManagerから取得したデータテンプレートを基にEntityを生成します。

## **7\. 結論**

本設計書は、Entity Component Systemアーキテクチャを中核に据え、Service Locatorパターンによる疎結合なサービスレイヤーを組み合わせることで、要件定義書が求める「奥深い戦略性」と「戦術的な3D戦闘」を、高いパフォーマンスと拡張性を両立させながら実現するための技術的な道筋を示したものです。各システムは、適切なデザインパターンを適用することで、責務が明確化され、堅牢かつ保守しやすい構造となっています。

#### **引用文献**

1. Unity ECSを使ってゲームを作っています｜Happy Elements株式会社 カカリアスタジオ \- note, 9月 17, 2025にアクセス、 [https://note.com/happyelements/n/n27e4fdb3b82c](https://note.com/happyelements/n/n27e4fdb3b82c)  
2. 古典的ゲームループからECSアーキテクチャまで \- Zenn, 9月 17, 2025にアクセス、 [https://zenn.dev/rita0222/articles/c22a8367e31b4d5f4eeb](https://zenn.dev/rita0222/articles/c22a8367e31b4d5f4eeb)  
3. Service Locator Design Pattern \- C\# Corner, 9月 17, 2025にアクセス、 [https://www.c-sharpcorner.com/UploadFile/dacca2/service-locator-design-pattern/](https://www.c-sharpcorner.com/UploadFile/dacca2/service-locator-design-pattern/)  
4. Service Locator \- Game Programming Patterns, 9月 17, 2025にアクセス、 [https://gameprogrammingpatterns.com/service-locator.html](https://gameprogrammingpatterns.com/service-locator.html)  
5. 【Unity】Unityで学ぶデザインパターン21: Strategy パターン【デザパタ】 \- Qiita, 9月 17, 2025にアクセス、 [https://qiita.com/Cova8bitdot/items/28dd773075cf6e9fefee](https://qiita.com/Cova8bitdot/items/28dd773075cf6e9fefee)  
6. 書評『ゲームエンジンアーキテクチャ 第3版』 | 国際ゲーム開発者協会日本, 9月 17, 2025にアクセス、 [https://www.igda.jp/2020/12/22/11349/](https://www.igda.jp/2020/12/22/11349/)  
7. エンティティ・コンポーネント・システム \- Wikipedia, 9月 17, 2025にアクセス、 [https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%B3%E3%83%86%E3%82%A3%E3%83%86%E3%82%A3%E3%83%BB%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%83%BB%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0](https://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%B3%E3%83%86%E3%82%A3%E3%83%86%E3%82%A3%E3%83%BB%E3%82%B3%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%8D%E3%83%B3%E3%83%88%E3%83%BB%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0)  
8. Rust \+ Entity Component System で仕様変更に強いゲーム設計 その１ 〜 序文 \- Qiita, 9月 17, 2025にアクセス、 [https://qiita.com/mas-yo/items/e7d1e247e5d4a9f47e92](https://qiita.com/mas-yo/items/e7d1e247e5d4a9f47e92)  
9. Service Locator Pattern in C\#: A Simple Example \- Stefano Ricciardi, 9月 17, 2025にアクセス、 [http://www.stefanoricciardi.com/2009/09/25/service-locator-pattern-in-csharpa-simple-example/](http://www.stefanoricciardi.com/2009/09/25/service-locator-pattern-in-csharpa-simple-example/)  
10. PATHFINDING IN 3D SPACE \- A\*, THETA\*, LAZY THETA\* IN OCTREE STRUCTURE \- Chia-Man Hung, 9月 17, 2025にアクセス、 [https://ascane.github.io/projects/07\_pathfinding3d/report.pdf](https://ascane.github.io/projects/07_pathfinding3d/report.pdf)  
11. C\# Design Pattern: Abstract Factory \- DEV Community, 9月 17, 2025にアクセス、 [https://dev.to/develop4us/c-design-pattern-abstract-factory-1oa2](https://dev.to/develop4us/c-design-pattern-abstract-factory-1oa2)  
12. Abstract Factory Pattern Made Simple in C\# \- YouTube, 9月 17, 2025にアクセス、 [https://www.youtube.com/watch?v=snVb75D\_msk](https://www.youtube.com/watch?v=snVb75D_msk)  
13. デザインパターンでコード改善！ ストラテジーパターンの紹介と適用事例, 9月 17, 2025にアクセス、 [https://developers.play.jp/entry/2025/02/06/184542](https://developers.play.jp/entry/2025/02/06/184542)  
14. 【C\#】Strategy パターン \- Zenn, 9月 17, 2025にアクセス、 [https://zenn.dev/xurenjun/articles/0e0474530841b8](https://zenn.dev/xurenjun/articles/0e0474530841b8)  
15. Strategy, 9月 17, 2025にアクセス、 [http://marupeke296.com/DP\_Strategy.html](http://marupeke296.com/DP_Strategy.html)  
16. Game Navigation: A\* Pathfinding in Unity \- Medium, 9月 17, 2025にアクセス、 [https://swapnilmore03.medium.com/game-navigation-a-pathfinding-in-unity-4e8203e3d40b](https://swapnilmore03.medium.com/game-navigation-a-pathfinding-in-unity-4e8203e3d40b)  
17. Design and Implementation of Pathfinding Algorithms in Unity 3D \- IJRASET, 9月 17, 2025にアクセス、 [https://www.ijraset.com/research-paper/design-and-implementation-of-pathfinding-algorithms-in-unity-3d](https://www.ijraset.com/research-paper/design-and-implementation-of-pathfinding-algorithms-in-unity-3d)
