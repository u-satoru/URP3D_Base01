# Phase 3.5: Combat機能の疎結合化 - 実装報告書

## 概要
**実施日**: 2025年9月23日
**フェーズ**: Phase 3.5
**目的**: Combat機能を3層アーキテクチャに準拠させ、イベント駆動とServiceLocatorパターンによる疎結合化を実現

## 実装内容

### 1. Combat機能の3層構造への分離

#### Core層
- **IHealthTarget**: 基本的な健康管理インターフェース（既存）
- **DamageCommand**: コマンドパターンによるダメージ処理（既存）
- **IEventManager**: イベント管理インターフェース（既存）
- **EventManager**: イベント管理実装（既存）

#### Feature層（Combat機能）
新規作成ファイル：
- `Features/Combat/Events/CombatEventNames.cs`: 戦闘イベント名の定義
- `Features/Combat/Interfaces/ICombatService.cs`: 戦闘システムサービスインターフェース
- `Features/Combat/Services/CombatService.cs`: 戦闘システムサービス実装

更新ファイル：
- `Features/Combat/Components/HealthComponent.cs`: イベント駆動化実装
  - ServiceLocatorからCombatServiceへの自動登録
  - EventManagerを使用したイベント発行

既存ファイル：
- `Features/Combat/Interfaces/IHealth.cs`: ヘルスシステムインターフェース
- `Features/Combat/Interfaces/IDamageable.cs`: ダメージ可能オブジェクトインターフェース
- `Features/Combat/Data/DamageInfo.cs`: ダメージ情報構造体
- `Features/Combat/Events/CombatEventData.cs`: 戦闘イベントデータクラス

### 2. ServiceLocatorパターンの統合

`Core/Bootstrap/GameBootstrapper.cs`の更新：
```csharp
private void RegisterFeatureServices()
{
    // CombatServiceの登録
    var combatService = new CombatService();
    ServiceLocator.Register<ICombatService>(combatService);
}
```

### 3. イベント駆動アーキテクチャの実装

#### 定義された戦闘イベント
- **ダメージ系**: OnDamageDealt, OnDamageReceived, OnCriticalHit
- **ヘルス系**: OnHealthChanged, OnHeal, OnHealthRestored
- **死亡/復活系**: OnDeath, OnRevive, OnRespawn
- **戦闘状態系**: OnCombatStarted, OnCombatEnded
- **武器系**: OnWeaponEquipped, OnWeaponFired, OnWeaponReload
- **防御系**: OnBlock, OnParry, OnDodge

### 4. CombatServiceの機能

#### 主要機能
- ダメージ処理の中央管理
- ヘルスコンポーネントの登録/管理
- 戦闘状態の追跡
- コマンドプール管理（ObjectPool統合）
- 戦闘統計の収集

#### 統計情報
```csharp
public struct CombatStatistics
{
    public int TotalDamageDealt;
    public int TotalDamageReceived;
    public int TotalHealing;
    public int Kills;
    public int Deaths;
    public float CombatTime;
    public int ActiveCombatants;
}
```

## アーキテクチャの利点

### 1. 疎結合の実現
- コンポーネント間の直接依存を排除
- イベント駆動による柔軟な通信
- ServiceLocatorによる依存性解決

### 2. 拡張性の向上
- 新しい戦闘機能の追加が容易
- 既存コードへの影響を最小化
- プラグイン形式での機能追加が可能

### 3. テスタビリティの改善
- モック可能なインターフェース設計
- 単体テストの記述が容易
- 統合テストの分離実行が可能

### 4. パフォーマンスの最適化
- ObjectPoolによるメモリ効率化
- イベントシステムによる処理の最適化
- 戦闘統計によるパフォーマンス監視

## 使用例

### ダメージを与える
```csharp
// ServiceLocatorから取得
var combatService = ServiceLocator.Get<ICombatService>();
combatService.DealDamage(target, 50f, damageInfo);
```

### ヘルスコンポーネントの登録
```csharp
// 自動登録（HealthComponent.Start()内で実行）
if (ServiceLocator.TryGet<ICombatService>(out var combatService))
{
    combatService.RegisterHealth(this);
}
```

### イベントの購読
```csharp
var eventManager = ServiceLocator.Get<IEventManager>();
eventManager.Subscribe<DamageEventData>(
    CombatEventNames.OnDamageDealt,
    OnDamageDealt
);
```

## 今後の拡張予定

### Phase 3.5.1: 追加機能
- バフ/デバフシステムの実装
- コンボシステムの統合
- 属性ダメージの拡張

### Phase 3.5.2: 最適化
- イベントのバッチ処理
- メモリプールの自動調整
- 非同期処理の導入（UniTask）

### Phase 3.5.3: テスト実装
- CombatServiceのユニットテスト
- イベント通信の統合テスト
- パフォーマンステスト

## まとめ

Phase 3.5では、Combat機能を3層アーキテクチャに準拠させ、ServiceLocator + Event駆動のハイブリッドアーキテクチャによる疎結合化を実現しました。これにより：

1. **関心の分離**: 戦闘ロジックが明確に分離され、管理が容易に
2. **再利用性**: インターフェースベースの設計により、異なるゲームジャンルでの再利用が可能
3. **拡張性**: 新機能の追加が既存コードに影響を与えずに実現可能
4. **保守性**: イベント駆動により、デバッグとメンテナンスが容易

次のフェーズでは、他のFeature層機能の疎結合化を進め、最終的にTemplate層での統合を目指します。