# プロジェクト静的コード検証レポート

## 1. 総合評価

このプロジェクトは、**ScriptableObjectベースのイベント駆動アーキテクチャ（EDA）** を基盤としており、その基盤自体は堅牢に実装されています。特にイベントチャネル（`GameEvent`, `GenericGameEvent`など）のシステムは、優先度管理やデバッグ機能も含まれており、非常に高機能です。

しかし、アプリケーション層（`PlayerController`, `PlayerStateMachine`など）において、アーキテクチャの原則から逸脱している箇所が複数見受けられ、**保守性、拡張性、および堅牢性において重大なリスク**を抱えています。

以下に、具体的な問題点と推奨事項を詳述します。

---

## 2. 発見された問題・懸念点

### 2.1. アーキテクチャ上の問題

#### A. `PlayerController`の肥大化（God Class問題）

- **現象**: `PlayerController.cs` は、現在500行を超えており、単一のクラスが過剰な責務を担っています。
  - 入力処理（Input Systemのコールバック）
  - 物理挙動の計算（移動、重力、ジャンプなど）
  - 状態管理（`currentMovementState`の決定）
  - イベントの発行（多数の`GameEvent`をInspectorから参照）
  - イベントの購読とハンドリング
  - プレイヤーのステータス管理（体力、スタミナ）
- **リスク**: このクラスは「[God Class](https://en.wikipedia.org/wiki/God_object)」アンチパターンに該当します。修正が困難で、デバッグが複雑になり、新しい機能の追加が既存の機能に予期せぬ影響を与える（リグレッション）可能性が非常に高い状態です。

#### B. 状態管理の責務重複と矛盾

- **現象**: プロジェクトには `PlayerController` と `PlayerStateMachine` の2つのクラスが存在し、両者がプレイヤーの状態を管理しようとしています。
  - `PlayerController`は自身の`UpdateMovementState()`で`currentMovementState`を決定し、`onStateChangeRequest`イベントを発行します。
  - `PlayerStateMachine`は、そのイベントをリッスンして自身の`currentState`を更新します。
- **リスク**: これは責務の重複です。状態の「真の所有者」が誰であるか不明確であり、ロジックが分散し、状態遷移のフローが追いにくくなっています。状態に関するバグが発生した場合、どちらを修正すべきかの判断が困難になります。

#### C. 未使用のステートパターン実装

- **現象**: `BasePlayerState.cs` およびその派生クラス（`IdleState`, `WalkingState`など）は、ステートパターンを実装するためのものです。しかし、`PlayerStateMachine`はこれらのクラスを一切使用せず、巨大な`switch`文で状態ごとの処理を分岐しています。
- **リスク**: 実装が不完全であるか、設計が途中で放棄されたことを示唆しています。`switch`文による状態管理は、状態が増えるにつれて保守性が著しく低下します（オープン/クローズド原則の違反）。

### 2.2. コンパイル・ビルド上の問題

現時点のコードでは、**直接的なコンパイルエラーは見つかりませんでした。** `asmdef`によるアセンブリ分割も行われており、基本的な構造は整っています。

### 2.3. ランタイム時の懸念事項

#### A. Inspectorへの過度な依存

- **現象**: `PlayerController`, `GameManager`, `CinemachineIntegration` を中心に、非常に多くの `[SerializeField]` フィールドが公開されており、その大半がイベントチャネルのアセットです。
- **リスク**: これらの参照はUnity EditorのInspector上で**手動で設定**する必要があります。1つでも設定が漏れていると、実行時に `NullReferenceException` が発生し、アプリケーションが停止します。コンポーネントが増えるほど、この設定ミスによるヒューマンエラーのリスクは増大します。

#### B. Input Systemへの暗黙的な依存

- **現象**: `PlayerController`は `playerActionMap.FindAction("Move")` のように、文字列でアクションを検索しています。
- **リスク**: Input Actionアセット側でアクション名（例: "Move"）が変更された場合、コンパイルエラーは発生せず、実行時にアクションが見つからず操作不能になるという問題が発生します。これは静的解析では検出困難な、典型的なランタイムエラーの元です。

---

## 3. 推奨事項

上記の問題点を解決し、プロジェクトをより堅牢で保守性の高い状態にするために、以下の段階的なリファクタリングを強く推奨します。

### 推奨1: `PlayerController`の責務を分離（Commandパターンの導入）

- **目的**: God Class問題を解決し、入力と実行を分離します。
- **方法**: 以前提案した**Commandパターン**を導入します。
  1. `PlayerController`の役割を**入力検知とコマンド生成・発行**のみに限定します。
  2. `OnMove`や`OnJump`内では、`MoveCommand`や`JumpCommand`を生成し、`CommandEvent`で発行します。
  3. 実際の移動処理やジャンプ処理は、`GameManager`や新設する`CommandProcessor`がコマンドを受け取って実行します。
- **効果**: `PlayerController`が劇的にシンプルになり、テストが容易になります。また、AIやネットワークなど、他の入力ソースからもプレイヤーを操作できるようになります。

### 推奨2: ステートマシンの責務を統一

- **目的**: 状態管理を一元化し、ロジックの重複を排除します。
- **方法**:
  1. **`PlayerStateMachine`を状態の唯一の所有者**とします。
  2. `PlayerStateMachine`が、未使用となっている`BasePlayerState`派生クラス群を使用するようにリファクタリングします。巨大な`switch`文を廃止し、現在のステートオブジェクトの`Update()`を呼び出す形に修正します。
  3. `PlayerController`からは状態決定ロジックを完全に削除します。
- **効果**: 状態遷移のロジックが`PlayerStateMachine`に集約され、見通しが良くなります。新しい状態の追加も、新しいステートクラスを作成するだけで済み、既存コードへの影響を最小限に抑えられます。

### 推奨3: Inspectorへの依存を低減する仕組みを導入

- **目的**: ランタイムエラーのリスクを低減します。
- **方法**:
  1. **自動参照解決**: Service Locatorパターンや、DI（Dependency Injection）コンテナを導入し、イベントチャネルなどをコードベースで解決する方法を検討します。
  2. **検証ツールの作成**: `[ContextMenu]`やEditor拡張を使用し、必要な参照がすべて設定されているかをチェックする検証ツールを`GameManager`などに実装します。

このレポートが、プロジェクトの品質向上の一助となれば幸いです。
