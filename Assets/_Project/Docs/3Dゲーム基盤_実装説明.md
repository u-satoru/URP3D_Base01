# Unity 6 3Dゲーム基盤実装説明書（最終版）

## 📁 現在のプロジェクト構造

```
Unity6_Fixed/
├── Assembly_Definitions/
│   ├── Unity6.Core.asmdef                 # コア機能のアセンブリ定義
│   ├── Unity6.Player.asmdef               # プレイヤー機能のアセンブリ定義
│   ├── Unity6.Camera.asmdef               # カメラシステムのアセンブリ定義
│   ├── Unity6.Systems.asmdef              # システム機能のアセンブリ定義
│   └── Unity6.Optimization.asmdef         # 最適化機能のアセンブリ定義
├── Core/
│   ├── Data/
│   │   └── GameData.cs                    # ゲームデータ定義
│   ├── Events/
│   │   ├── GameEvent.cs                   # 基本イベントチャネル
│   │   ├── GenericGameEvent.cs            # ジェネリック型付きイベント
│   │   ├── GameEventListener.cs           # イベントリスナー
│   │   ├── IGameEventListener.cs          # リスナーインターフェース
│   │   ├── GameDataEvent.cs               # データイベント定義
│   │   ├── PlayerStateEvent.cs            # プレイヤー状態イベント
│   │   ├── Vector2GameEvent.cs            # Vector2パラメータ付きイベント
│   │   ├── Vector2GameEventListener.cs    # Vector2イベントリスナー
│   │   └── CameraStateEvent.cs            # カメラ状態変更イベント
│   └── Player/
│       └── PlayerState.cs                 # 統一enum定義
├── Player/
│   ├── PlayerController.cs                # プレイヤーコントローラー（最終版）
│   ├── PlayerStateMachine.cs              # ステートマシン
│   └── States/
│       └── BasePlayerState.cs             # 基底ステートクラス
├── Camera/
│   └── CinemachineIntegration.cs          # Cinemachine 3.1統合システム
└── Systems/
    └── GameManager.cs                     # ゲームマネージャー（最終版）
```

## 🔧 実装済みコンポーネント

### 1. **イベントシステム基盤**

#### Core/Events/GameEvent.cs
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

namespace Unity6.Core.Events
{
    [CreateAssetMenu(fileName = "New Game Event", menuName = "Unity6/Events/Game Event")]
    public class GameEvent : ScriptableObject
    {
        private readonly HashSet<GameEventListener> listeners = new HashSet<GameEventListener>();
        private List<GameEventListener> sortedListeners;
        private bool isDirty = true;
        
        #if UNITY_EDITOR
        [Header("Debug Settings")]
        [SerializeField] private bool debugMode = false;
        [SerializeField, TextArea(3, 5)] private string eventDescription;
        #endif
        
        public void Raise()
        {
            if (isDirty)
            {
                RebuildSortedList();
            }
            
            for (int i = sortedListeners.Count - 1; i >= 0; i--)
            {
                if (sortedListeners[i] != null && sortedListeners[i].enabled)
                {
                    sortedListeners[i].OnEventRaised();
                }
            }
        }
        
        public void RegisterListener(GameEventListener listener)
        {
            if (listener == null) return;
            if (listeners.Add(listener))
            {
                isDirty = true;
            }
        }
        
        public void UnregisterListener(GameEventListener listener)
        {
            if (listener == null) return;
            if (listeners.Remove(listener))
            {
                isDirty = true;
            }
        }
        
        private void RebuildSortedList()
        {
            sortedListeners = listeners
                .Where(l => l != null)
                .OrderByDescending(l => l.Priority)
                .ToList();
            isDirty = false;
        }
    }
}
```

#### Core/Events/GenericGameEvent.cs
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

namespace Unity6.Core.Events
{
    public abstract class GenericGameEvent<T> : ScriptableObject
    {
        private readonly HashSet<IGameEventListener<T>> listeners = new HashSet<IGameEventListener<T>>();
        
        #if UNITY_EDITOR
        [Header("Debug Settings")]
        [SerializeField] private bool debugMode = false;
        #endif
        
        public void Raise(T value)
        {
            var activeListeners = listeners.Where(l => l != null).ToArray();
            foreach (var listener in activeListeners)
            {
                listener.OnEventRaised(value);
            }
        }
        
        public void RegisterListener(IGameEventListener<T> listener)
        {
            if (listener == null) return;
            listeners.Add(listener);
        }
        
        public void UnregisterListener(IGameEventListener<T> listener)
        {
            if (listener == null) return;
            listeners.Remove(listener);
        }
    }
    
    // 具体的な型の実装
    [CreateAssetMenu(fileName = "New Float Event", menuName = "Unity6/Events/Float Event")]
    public class FloatGameEvent : GenericGameEvent<float> { }
    
    [CreateAssetMenu(fileName = "New Int Event", menuName = "Unity6/Events/Int Event")]
    public class IntGameEvent : GenericGameEvent<int> { }
    
    [CreateAssetMenu(fileName = "New Bool Event", menuName = "Unity6/Events/Bool Event")]
    public class BoolGameEvent : GenericGameEvent<bool> { }
    
    [CreateAssetMenu(fileName = "New String Event", menuName = "Unity6/Events/String Event")]
    public class StringGameEvent : GenericGameEvent<string> { }
    
    [CreateAssetMenu(fileName = "New Vector3 Event", menuName = "Unity6/Events/Vector3 Event")]
    public class Vector3GameEvent : GenericGameEvent<Vector3> { }
}
```

#### Core/Events/Vector2GameEvent.cs
```csharp
using UnityEngine;
using System.Collections.Generic;
using System.Linq;

namespace Unity6.Core.Events
{
    /// <summary>
    /// Vector2パラメータ付きイベントチャネル
    /// カメラのルック入力用に最適化
    /// </summary>
    [CreateAssetMenu(fileName = "New Vector2 Game Event", menuName = "Unity6/Events/Vector2 Game Event")]
    public class Vector2GameEvent : ScriptableObject
    {
        private readonly HashSet<Vector2GameEventListener> listeners = new HashSet<Vector2GameEventListener>();
        private List<Vector2GameEventListener> sortedListeners;
        private bool isDirty = true;
        
        #if UNITY_EDITOR
        [Header("Debug Settings")]
        [SerializeField] private bool debugMode = false;
        [SerializeField, TextArea(3, 5)] private string eventDescription;
        
        [Header("Runtime Info (Editor Only)")]
        [SerializeField, Unity6.Core.Attributes.ReadOnly] private int listenerCount;
        [SerializeField, Unity6.Core.Attributes.ReadOnly] private Vector2 lastRaisedValue;
        #endif
        
        /// <summary>
        /// イベントを発行
        /// </summary>
        /// <param name="value">Vector2値</param>
        public void Raise(Vector2 value)
        {
            #if UNITY_EDITOR
            lastRaisedValue = value;
            listenerCount = listeners.Count;
            
            if (debugMode)
            {
                Debug.Log($"[Vector2GameEvent] '{name}' raised with value: {value}, Listeners: {listeners.Count}");
            }
            #endif
            
            // リスナーリストが変更されている場合はソートし直す
            if (isDirty)
            {
                RebuildSortedListeners();
            }
            
            // 優先度順にイベントを通知
            for (int i = sortedListeners.Count - 1; i >= 0; i--)
            {
                var listener = sortedListeners[i];
                if (listener != null && listener.gameObject.activeInHierarchy)
                {
                    listener.OnEventRaised(value);
                }
            }
        }
        
        /// <summary>
        /// リスナーを登録
        /// </summary>
        public void RegisterListener(Vector2GameEventListener listener)
        {
            if (listeners.Add(listener))
            {
                isDirty = true;
                
                #if UNITY_EDITOR
                if (debugMode)
                {
                    Debug.Log($"[Vector2GameEvent] Listener registered: {listener.name}");
                }
                #endif
            }
        }
        
        /// <summary>
        /// リスナーを解除
        /// </summary>
        public void UnregisterListener(Vector2GameEventListener listener)
        {
            if (listeners.Remove(listener))
            {
                isDirty = true;
                
                #if UNITY_EDITOR
                if (debugMode)
                {
                    Debug.Log($"[Vector2GameEvent] Listener unregistered: {listener.name}");
                }
                #endif
            }
        }
        
        private void RebuildSortedListeners()
        {
            sortedListeners = listeners
                .Where(l => l != null)
                .OrderBy(l => l.Priority)
                .ToList();
            isDirty = false;
        }
    }
}
```

#### Core/Events/Vector2GameEventListener.cs
```csharp
using UnityEngine;
using UnityEngine.Events;

namespace Unity6.Core.Events
{
    /// <summary>
    /// Vector2パラメータ付きイベントリスナー
    /// カメラルック入力用
    /// </summary>
    public class Vector2GameEventListener : MonoBehaviour, IGameEventListener<Vector2>
    {
        [Header("Event Configuration")]
        [SerializeField] private Vector2GameEvent gameEvent;
        
        [Header("Listener Settings")]
        [SerializeField] private int priority = 0;
        
        [Header("Response")]
        [SerializeField] private UnityEvent<Vector2> Response;
        
        /// <summary>
        /// 実行優先度（数値が大きいほど優先）
        /// </summary>
        public int Priority => priority;
        
        private void OnEnable()
        {
            if (gameEvent != null)
            {
                gameEvent.RegisterListener(this);
            }
        }
        
        private void OnDisable()
        {
            if (gameEvent != null)
            {
                gameEvent.UnregisterListener(this);
            }
        }
        
        /// <summary>
        /// Vector2GameEventが発生した時の処理
        /// </summary>
        /// <param name="value">Vector2値</param>
        public void OnEventRaised(Vector2 value)
        {
            // メソッドが設定されている場合のみ実行
            if (Response != null)
            {
                Response.Invoke(value);
            }
        }
    }
}
    [CreateAssetMenu(fileName = "New GameObject Event", menuName = "Unity6/Events/GameObject Event")]
    public class GameObjectGameEvent : GenericGameEvent<GameObject> { }
}
```

### 2. **統一enum定義**

#### Core/Player/PlayerState.cs
```csharp
namespace Unity6.Core.Player
{
    /// <summary>
    /// プレイヤーの状態を表す統一enum
    /// </summary>
    public enum PlayerState
    {
        // 基本状態
        Idle,
        Walking,
        Running,
        Sprinting,
        
        // 空中状態
        Jumping,
        Falling,
        Landing,
        
        // 戦闘状態
        Combat,
        CombatIdle,
        CombatAttacking,
        CombatDefending,
        CombatDodging,
        
        // 特殊状態
        Interacting,
        Swimming,
        Climbing,
        Sliding,
        Dead
    }
    
    /// <summary>
    /// ゲームの状態を表す統一enum
    /// </summary>
    public enum GameState
    {
        MainMenu,
        Loading,
        Playing,
        Paused,
        GameOver,
        Victory
    }
}
```

### 3. **プレイヤー状態イベント**

#### Core/Events/PlayerStateEvent.cs
```csharp
using UnityEngine;
using UnityEngine.Events;
using Unity6.Core.Player;

namespace Unity6.Core.Events
{
    /// <summary>
    /// PlayerState用のイベント定義
    /// </summary>
    [CreateAssetMenu(fileName = "PlayerStateEvent", menuName = "Unity6/Events/Player State Event")]
    public class PlayerStateEvent : GenericGameEvent<PlayerState> { }
    
    /// <summary>
    /// GameState用のイベント定義
    /// </summary>
    [CreateAssetMenu(fileName = "GameStateEvent", menuName = "Unity6/Events/Game State Event")]
    public class GameStateEvent : GenericGameEvent<GameState> { }
    
    /// <summary>
    /// PlayerStateEventListener
    /// </summary>
    public class PlayerStateEventListener : GenericGameEventListener<PlayerState, PlayerStateEvent, UnityPlayerStateEvent> { }
    
    /// <summary>
    /// GameStateEventListener
    /// </summary>
    public class GameStateEventListener : GenericGameEventListener<GameState, GameStateEvent, UnityGameStateEvent> { }
    
    [System.Serializable]
    public class UnityPlayerStateEvent : UnityEvent<PlayerState> { }
    
    [System.Serializable]
    public class UnityGameStateEvent : UnityEvent<GameState> { }
}
```

### 3.1. **カメラ状態イベント**

#### Core/Events/CameraStateEvent.cs
```csharp
using UnityEngine;

namespace Unity6.Core.Events
{
    /// <summary>
    /// カメラ状態の列挙型
    /// </summary>
    public enum CameraState
    {
        Follow,          // 通常の追従カメラ
        Aim,             // エイム時のカメラ
        Combat,          // 戦闘時のカメラ
        Cinematic,       // シネマティックカメラ
        Dead,            // 死亡時のカメラ
        Menu,            // メニュー時のカメラ
        Cutscene,        // カットシーン
        FreeLook,        // フリールック
        FirstPerson,     // 一人称視点
        ThirdPerson      // 三人称視点
    }
    
    /// <summary>
    /// カメラ状態変更イベント
    /// </summary>
    [CreateAssetMenu(fileName = "New Camera State Event", menuName = "Unity6/Events/Camera State Event")]
    public class CameraStateEvent : GenericGameEvent<CameraState>
    {
        #if UNITY_EDITOR
        [Header("Camera State Event Settings")]
        [SerializeField, TextArea(2, 4)] 
        private string cameraStateDescription = "カメラの状態変更を通知するイベント";
        #endif
        
        /// <summary>
        /// カメラ状態を変更
        /// </summary>
        /// <param name="newState">新しいカメラ状態</param>
        public void ChangeCameraState(CameraState newState)
        {
            #if UNITY_EDITOR
            if (Application.isPlaying)
            {
                Debug.Log($"[CameraStateEvent] Camera state changed to: {newState}");
            }
            #endif
            
            Raise(newState);
        }
    }
}
```

### 4. **データ定義**

#### Core/Data/GameData.cs
```csharp
using UnityEngine;
using System.Collections.Generic;

namespace Unity6.Core.Data
{
    /// <summary>
    /// ゲームデータのペイロード
    /// </summary>
    [System.Serializable]
    public class GameData
    {
        public int level;
        public float gameTime;
        public int score;
        public int lives;
        public int highScore;
        public string playerName;
        public Dictionary<string, object> customData;
        
        public GameData()
        {
            customData = new Dictionary<string, object>();
        }
    }
    
    /// <summary>
    /// プレイヤーデータのペイロード
    /// </summary>
    [System.Serializable]
    public class PlayerDataPayload
    {
        public string playerName;
        public Vector3 position;
        public Quaternion rotation;
        public float currentHealth;
        public float maxHealth;
        public float currentStamina;
        public float maxStamina;
        public int score;
    }
}
```

### 5. **PlayerController（最終版）**

#### Player/PlayerController.cs（主要部分）
```csharp
using UnityEngine;
using UnityEngine.InputSystem;
using Unity6.Core.Events;
using Unity6.Core.Player;
using Unity6.Core.Data;
using System.Collections;
using System.Collections.Generic;

namespace Unity6.Player
{
    /// <summary>
    /// プレイヤーコントローラー
    /// 静的リスナー方式と自動状態遷移を実装
    /// </summary>
    [RequireComponent(typeof(CharacterController))]
    [RequireComponent(typeof(PlayerInput))]
    public class PlayerController : MonoBehaviour
    {
        #region Movement Settings
        [Header("Movement Settings")]
        [SerializeField] private float walkSpeed = 3f;
        [SerializeField] private float runSpeed = 6f;
        [SerializeField] private float sprintSpeed = 9f;
        [SerializeField] private float jumpHeight = 2f;
        [SerializeField] private float gravity = -19.81f;
        #endregion
        
        #region Event Listeners - Static
        [Header("Static Event Listeners")]
        [SerializeField] private GameEventListener damageReceivedListener;
        [SerializeField] private FloatGameEventListener damageAmountListener;
        [SerializeField] private PlayerStateEventListener forceStateChangeListener;
        #endregion
        
        #region Events - Output
        [Header("State Change Events (Output)")]
        [SerializeField] private PlayerStateEvent onStateChangeRequest;
        [SerializeField] private BoolGameEvent onGroundedChanged;
        [SerializeField] private FloatGameEvent onHealthChanged;
        [SerializeField] private FloatGameEvent onStaminaChanged;
        #endregion
        
        private PlayerState currentMovementState = PlayerState.Idle;
        private CharacterController controller;
        private PlayerInput playerInput;
        
        private void Awake()
        {
            controller = GetComponent<CharacterController>();
            playerInput = GetComponent<PlayerInput>();
            SetupInputCallbacks();
        }
        
        private void OnEnable()
        {
            RegisterEventListeners();
        }
        
        private void OnDisable()
        {
            UnregisterEventListeners();
        }
        
        private void RegisterEventListeners()
        {
            // 静的リスナーのUnityEventにハンドラーを登録
            if (damageReceivedListener != null)
                damageReceivedListener.Response.AddListener(OnDamageReceived);
            
            if (damageAmountListener != null)
                damageAmountListener.response.AddListener(OnDamageAmountReceived);
            
            if (forceStateChangeListener != null)
                forceStateChangeListener.response.AddListener(OnForceStateChange);
        }
        
        private void UnregisterEventListeners()
        {
            // UnityEventからハンドラーを削除
            if (damageReceivedListener != null)
                damageReceivedListener.Response.RemoveListener(OnDamageReceived);
            
            if (damageAmountListener != null)
                damageAmountListener.response.RemoveListener(OnDamageAmountReceived);
            
            if (forceStateChangeListener != null)
                forceStateChangeListener.response.RemoveListener(OnForceStateChange);
        }
        
        private void UpdateMovementState()
        {
            PlayerState newState = DetermineMovementState();
            
            if (newState != currentMovementState)
            {
                currentMovementState = newState;
                onStateChangeRequest?.Raise(newState);
            }
        }
        
        private PlayerState DetermineMovementState()
        {
            // 速度に基づく状態決定ロジック
            // 実装の詳細はプロジェクトの要件に応じて調整
            return currentMovementState;
        }
    }
}
```

### 6. **GameManager（最終版）**

#### Systems/GameManager.cs（主要部分）
```csharp
using UnityEngine;
using UnityEngine.SceneManagement;
using Unity6.Core.Events;
using Unity6.Core.Player;
using Unity6.Core.Data;
using System.Collections;
using System.Collections.Generic;

namespace Unity6.Systems
{
    /// <summary>
    /// ゲームマネージャー
    /// 完全イベント駆動・エラーハンドリング強化
    /// </summary>
    public class GameManager : MonoBehaviour
    {
        [Header("Game State")]
        [SerializeField] private GameState currentGameState = GameState.MainMenu;
        [SerializeField] private GameState previousGameState = GameState.MainMenu;
        
        [Header("Event Channels - Input")]
        [SerializeField] private GameEvent onStartGameCommand;
        [SerializeField] private GameEvent onPauseGameCommand;
        [SerializeField] private GameEvent onResumeGameCommand;
        
        [Header("Event Channels - Output")]
        [SerializeField] private GameStateEvent gameStateChangedEvent;
        [SerializeField] private GameDataEvent gameDataUpdatedEvent;
        
        [Header("Event Listeners")]
        [SerializeField] private GameEventListener startGameListener;
        [SerializeField] private GameEventListener pauseGameListener;
        [SerializeField] private GameEventListener resumeGameListener;
        
        private Dictionary<string, Coroutine> activeCoroutines = new Dictionary<string, Coroutine>();
        
        private void Awake()
        {
            if (!ValidateSetup())
            {
                enabled = false;
                return;
            }
            
            InitializeGameManager();
        }
        
        private void OnEnable()
        {
            RegisterEventListeners();
        }
        
        private void OnDisable()
        {
            UnregisterEventListeners();
        }
        
        private void RegisterEventListeners()
        {
            // 静的リスナーにハンドラーを登録
            if (startGameListener != null)
                startGameListener.Response.AddListener(HandleStartGame);
            
            if (pauseGameListener != null)
                pauseGameListener.Response.AddListener(HandlePauseGame);
            
            if (resumeGameListener != null)
                resumeGameListener.Response.AddListener(HandleResumeGame);
        }
        
        private void UnregisterEventListeners()
        {
            // リスナーからハンドラーを削除
            if (startGameListener != null)
                startGameListener.Response.RemoveListener(HandleStartGame);
            
            if (pauseGameListener != null)
                pauseGameListener.Response.RemoveListener(HandlePauseGame);
            
            if (resumeGameListener != null)
                resumeGameListener.Response.RemoveListener(HandleResumeGame);
        }
        
        private void HandleStartGame()
        {
            ChangeGameState(GameState.Playing);
        }
        
        private void HandlePauseGame()
        {
            if (currentGameState == GameState.Playing)
                ChangeGameState(GameState.Paused);
        }
        
        private void HandleResumeGame()
        {
            if (currentGameState == GameState.Paused)
                ChangeGameState(GameState.Playing);
        }
        
        public void ChangeGameState(GameState newState)
        {
            if (currentGameState == newState)
                return;
            
            previousGameState = currentGameState;
            currentGameState = newState;
            
            gameStateChangedEvent?.Raise(currentGameState);
        }
    }
}
```

### 7. **PlayerStateMachine**

#### Player/PlayerStateMachine.cs（主要部分）
```csharp
using UnityEngine;
using Unity6.Core.Events;
using Unity6.Core.Player;

namespace Unity6.Player
{
    /// <summary>
    /// プレイヤーの状態管理を行うステートマシン
    /// </summary>
    public class PlayerStateMachine : MonoBehaviour
    {
        [Header("State Configuration")]
        [SerializeField] private PlayerState currentState = PlayerState.Idle;
        [SerializeField] private PlayerState previousState = PlayerState.Idle;
        
        [Header("Event Channels")]
        [SerializeField] private PlayerStateEvent stateChangeRequestEvent;
        [SerializeField] private PlayerStateEvent stateChangedEvent;
        
        public PlayerState CurrentState => currentState;
        public PlayerState PreviousState => previousState;
        
        // 状態変更イベント
        public event System.Action<PlayerState, PlayerState> OnStateChanged;
        
        public void ChangeState(PlayerState newState)
        {
            if (currentState == newState)
                return;
            
            PlayerState oldState = currentState;
            
            ExitState(currentState);
            previousState = currentState;
            currentState = newState;
            EnterState(currentState);
            
            OnStateChanged?.Invoke(oldState, currentState);
            stateChangedEvent?.Raise(currentState);
        }
        
        /// <summary>
        /// 状態遷移（BasePlayerStateから呼び出される）
        /// </summary>
        public void TransitionTo(PlayerState newState)
        {
            ChangeState(newState);
        }
        
        private void EnterState(PlayerState state)
        {
            // 状態開始時の処理
        }
        
        private void ExitState(PlayerState state)
        {
            // 状態終了時の処理
        }
    }
}
```

### 7. **Cinemachine 3.1統合システム**

#### Camera/CinemachineIntegration.cs（主要部分）
```csharp
using UnityEngine;
using Cinemachine;
using Unity6.Core.Events;
using Unity6.Core.Player;
using Unity6.Camera.Events;
using System.Collections.Generic;
using System.Collections;

namespace Unity6.Camera
{
    /// <summary>
    /// Cinemachine 3.1統合カメラシステム
    /// Unity 6最適化版 - イベント駆動アーキテクチャ対応
    /// </summary>
    public class CinemachineIntegration : MonoBehaviour
    {
        private static CinemachineIntegration instance;
        public static CinemachineIntegration Instance => instance;
        
        #region Camera Configuration
        [System.Serializable]
        public class CameraConfig
        {
            [Header("Basic Settings")]
            public string cameraName;
            public CinemachineVirtualCamera virtualCamera;
            public CameraState cameraState;
            public int defaultPriority = 10;
            
            [Header("Transition Settings")]
            public float blendTime = 1f;
            public CinemachineBlendDefinition.Style blendStyle = 
                CinemachineBlendDefinition.Style.EaseInOut;
            
            [Header("Events")]
            public GameEvent activationEvent;
            public GameEvent deactivationEvent;
            
            [Header("FOV Settings")]
            public float fieldOfView = 60f;
            public float minFOV = 30f;
            public float maxFOV = 120f;
        }
        #endregion
        
        #region Inspector Fields
        [Header("Camera System Configuration")]
        [SerializeField] private List<CameraConfig> cameraConfigs = new List<CameraConfig>();
        [SerializeField] private CameraState defaultCameraState = CameraState.Follow;
        
        [Header("Event Channels")]
        [SerializeField] private CameraStateEvent cameraStateChangeEvent;
        [SerializeField] private Vector2GameEvent lookInputEvent;
        [SerializeField] private GameEvent aimStartedEvent;
        [SerializeField] private GameEvent aimEndedEvent;
        
        [Header("Look Settings")]
        [SerializeField] private float lookSensitivity = 2f;
        [SerializeField] private float verticalLookLimit = 80f;
        [SerializeField] private bool invertYAxis = false;
        
        [Header("Transition Settings")]
        [SerializeField] private float defaultBlendTime = 1f;
        [SerializeField] private AnimationCurve transitionCurve = AnimationCurve.EaseInOut(0f, 0f, 1f, 1f);
        #endregion
        
        #region Private Fields
        private CameraState currentCameraState;
        private CameraConfig activeCameraConfig;
        private Dictionary<CameraState, CameraConfig> cameraStateLookup;
        
        // Look Input
        private Vector2 currentLookInput;
        private float currentVerticalRotation;
        
        // Cinemachine Components
        private CinemachineBrain cinemachineBrain;
        private Transform playerTarget;
        #endregion
        
        #region Unity Lifecycle
        private void Awake()
        {
            // Singleton Pattern
            if (instance == null)
            {
                instance = this;
                DontDestroyOnLoad(gameObject);
                InitializeCameraSystem();
            }
            else
            {
                Destroy(gameObject);
            }
        }
        
        private void Start()
        {
            SetupDefaultCamera();
        }
        
        private void OnEnable()
        {
            RegisterEventListeners();
        }
        
        private void OnDisable()
        {
            UnregisterEventListeners();
        }
        #endregion
        
        #region Initialization
        private void InitializeCameraSystem()
        {
            // Cinemachine Brain コンポーネントを取得または追加
            cinemachineBrain = Camera.main.GetComponent<CinemachineBrain>();
            if (cinemachineBrain == null)
            {
                cinemachineBrain = Camera.main.gameObject.AddComponent<CinemachineBrain>();
            }
            
            // カメラ状態の辞書を構築
            BuildCameraStateLookup();
            
            // 初期カメラ状態を設定
            currentCameraState = defaultCameraState;
        }
        
        private void BuildCameraStateLookup()
        {
            cameraStateLookup = new Dictionary<CameraState, CameraConfig>();
            
            foreach (var config in cameraConfigs)
            {
                if (config.virtualCamera != null && !cameraStateLookup.ContainsKey(config.cameraState))
                {
                    cameraStateLookup[config.cameraState] = config;
                }
            }
        }
        
        private void SetupDefaultCamera()
        {
            if (cameraStateLookup.ContainsKey(defaultCameraState))
            {
                SwitchToCamera(defaultCameraState);
            }
        }
        #endregion
        
        #region Event System
        private void RegisterEventListeners()
        {
            if (cameraStateChangeEvent != null)
            {
                cameraStateChangeEvent.RegisterListener(OnCameraStateChangeRequested);
            }
            
            if (lookInputEvent != null)
            {
                lookInputEvent.RegisterListener(OnLookInputReceived);
            }
        }
        
        private void UnregisterEventListeners()
        {
            if (cameraStateChangeEvent != null)
            {
                cameraStateChangeEvent.UnregisterListener(OnCameraStateChangeRequested);
            }
            
            if (lookInputEvent != null)
            {
                lookInputEvent.UnregisterListener(OnLookInputReceived);
            }
        }
        
        private void OnCameraStateChangeRequested(CameraState newState)
        {
            SwitchToCamera(newState);
        }
        
        private void OnLookInputReceived(Vector2 lookInput)
        {
            currentLookInput = lookInput;
            ApplyLookInput();
        }
        #endregion
        
        #region Camera Control
        /// <summary>
        /// 指定されたカメラ状態に切り替え
        /// </summary>
        public void SwitchToCamera(CameraState targetState)
        {
            if (!cameraStateLookup.ContainsKey(targetState))
            {
                Debug.LogWarning($"[CinemachineIntegration] Camera state '{targetState}' not configured!");
                return;
            }
            
            var targetConfig = cameraStateLookup[targetState];
            
            // 現在のカメラを非アクティブ化
            if (activeCameraConfig != null && activeCameraConfig.virtualCamera != null)
            {
                activeCameraConfig.virtualCamera.Priority = 0;
                
                // 非アクティブ化イベントを発行
                if (activeCameraConfig.deactivationEvent != null)
                {
                    activeCameraConfig.deactivationEvent.Raise();
                }
            }
            
            // 新しいカメラをアクティブ化
            activeCameraConfig = targetConfig;
            currentCameraState = targetState;
            
            if (activeCameraConfig.virtualCamera != null)
            {
                activeCameraConfig.virtualCamera.Priority = activeCameraConfig.defaultPriority;
                
                // アクティブ化イベントを発行
                if (activeCameraConfig.activationEvent != null)
                {
                    activeCameraConfig.activationEvent.Raise();
                }
            }
            
            // ブレンド時間を設定
            if (cinemachineBrain != null)
            {
                cinemachineBrain.m_DefaultBlend.m_Time = activeCameraConfig.blendTime;
                cinemachineBrain.m_DefaultBlend.m_Style = activeCameraConfig.blendStyle;
            }
            
            Debug.Log($"[CinemachineIntegration] Switched to camera: {targetState}");
        }
        
        /// <summary>
        /// ルック入力を適用
        /// </summary>
        private void ApplyLookInput()
        {
            if (activeCameraConfig?.virtualCamera == null)
                return;
            
            Vector2 scaledInput = currentLookInput * lookSensitivity * Time.deltaTime;
            
            if (invertYAxis)
            {
                scaledInput.y = -scaledInput.y;
            }
            
            // 垂直回転の制限
            currentVerticalRotation -= scaledInput.y;
            currentVerticalRotation = Mathf.Clamp(currentVerticalRotation, -verticalLookLimit, verticalLookLimit);
            
            // Cinemachine Virtual Cameraに回転を適用
            var composer = activeCameraConfig.virtualCamera.GetCinemachineComponent<CinemachineComposer>();
            if (composer != null)
            {
                // カメラの縦回転を制御
                composer.m_TrackedObjectOffset.y = currentVerticalRotation * 0.01f;
            }
            
            // 横回転はプレイヤーのTransformで処理（PlayerControllerと連携）
            if (playerTarget != null)
            {
                playerTarget.Rotate(Vector3.up * scaledInput.x);
            }
        }
        #endregion
        
        #region Public API
        /// <summary>
        /// プレイヤーターゲットを設定
        /// </summary>
        public void SetPlayerTarget(Transform target)
        {
            playerTarget = target;
            
            // 全てのVirtual Cameraのターゲットを更新
            foreach (var config in cameraConfigs)
            {
                if (config.virtualCamera != null)
                {
                    config.virtualCamera.Follow = target;
                    config.virtualCamera.LookAt = target;
                }
            }
        }
        
        /// <summary>
        /// FOVを変更
        /// </summary>
        public void SetFieldOfView(float fov)
        {
            if (activeCameraConfig?.virtualCamera != null)
            {
                fov = Mathf.Clamp(fov, activeCameraConfig.minFOV, activeCameraConfig.maxFOV);
                activeCameraConfig.virtualCamera.m_Lens.FieldOfView = fov;
            }
        }
        
        /// <summary>
        /// 現在のカメラ状態を取得
        /// </summary>
        public CameraState GetCurrentCameraState()
        {
            return currentCameraState;
        }
        #endregion
    }
}
```

## 🎯 実装の特徴

### 1. **完全なイベント駆動アーキテクチャ**
- ScriptableObjectベースのイベントシステム
- コンポーネント間の疎結合
- enum値による型安全な通信

### 2. **メモリ効率の最適化**
- 静的リスナー方式（動的生成の排除）
- HashSetによる高速リスナー管理
- コルーチン管理システム

### 3. **Unity 6対応**
- Unity 6 (6000.0.42f1) 完全対応
- 新Input System完全統合
- Assembly Definition構造化

### 4. **統合Cinemachineシステム**
- Cinemachine 3.1完全対応
- イベント駆動カメラ切り替え
- Vector2入力によるスムーズなルック制御
- 状態ベースカメラ管理
- カスタムブレンド設定対応

## 📋 Inspector設定手順

### PlayerControllerの設定
1. GameObjectにPlayerControllerを追加
2. 必要なリスナーコンポーネントを事前に追加
3. Events欄にScriptableObjectイベントを設定

### PlayerStateMachineの設定
1. stateChangeRequestEventにPlayerStateEventアセットを設定
2. stateChangedEventに同じまたは別のPlayerStateEventアセットを設定

### GameManagerの設定
1. 各種リスナーをGameObjectに追加
2. イベントチャネルを適切に接続
3. シーン名とロード設定を確認

## ⚠️ 注意事項

### パフォーマンス最適化
- enum値での状態管理（文字列変換なし）
- HashSetによるO(1)のリスナー追加/削除
- 優先度付きリスナーのキャッシュ機構
- null条件演算子による安全な呼び出し

### 必要なPackages
- Input System (com.unity.inputsystem) 1.7.0以上
- Cinemachine (com.unity.cinemachine) 3.1.0以上
- Universal RP (オプション)

### Assembly Definitions
- **Unity6.Core.asmdef**: 基本イベントシステムとデータ定義
- **Unity6.Player.asmdef**: プレイヤーコントローラーとステートマシン（Unity6.Core, Unity6.Camera, Unity.InputSystemに依存）
- **Unity6.Camera.asmdef**: Cinemachine統合システム（Unity6.Core, Unity6.Player, Unity.Cinemachineに依存）
- **Unity6.Systems.asmdef**: ゲームマネージャーと高レベルシステム（Unity6.Coreに依存）
- **Unity6.Optimization.asmdef**: パフォーマンス最適化機能

## 🚀 次のステップ

1. **ScriptableObjectアセット作成**
   - Project → Create → Unity6 → Events
   - 各種GameEvent、PlayerStateEvent、CameraStateEvent等を作成
   - Vector2GameEventアセットの作成

2. **Cinemachineセットアップ**
   - Cinemachine Virtual Cameraを各カメラ状態用に作成
   - CinemachineIntegrationコンポーネントの設定
   - Camera Configsに各Virtual Cameraを割り当て

3. **Inspector設定**
   - 各コンポーネントのSerializedFieldを設定
   - イベントの接続を確認
   - カメラ間のブレンド設定調整

4. **テスト環境構築**
   - Unity Test Frameworkの設定
   - イベントシステムのユニットテスト
   - カメラ切り替えの動作テスト

## 📚 参考資料

- [Unity 6 Documentation](https://docs.unity3d.com/6000.0/Documentation/Manual/)
- [Cinemachine Documentation](https://docs.unity3d.com/Packages/com.unity.cinemachine@3.1/manual/index.html)
- [ScriptableObject Event System Pattern](https://unity.com/how-to/architect-game-code-scriptable-objects)
- [Unity Input System](https://docs.unity3d.com/Packages/com.unity.inputsystem@latest)
- [Event-Driven Architecture in Unity](https://unity.com/how-to/create-modular-game-architecture-scriptable-objects)