namespace asterivo.Unity60.Core.Commands
{
    /// <summary>
    /// コマンド実行・Undo・Redo機能統合管理インターフェース
    ///
    /// Unity 6における3層アーキテクチャのCore層コマンドシステムにおいて、
    /// コマンド実行管理の統一契約を定義する中核インターフェースです。
    /// GoFデザインパターンのCommandパターンを基盤とし、Undo/Redo機能、
    /// ObjectPool最適化、ServiceLocator統合の包括的なコマンド実行管理を提供します。
    ///
    /// 【コマンド実行管理の核心価値】
    /// - 実行統制: コマンドの中央集権的実行とライフサイクル管理
    /// - 履歴管理: Undo/Redoスタックによる操作履歴の追跡と巻き戻し
    /// - 状態監視: 実行可能性の事前検証と安全な操作保証
    /// - パフォーマンス最適化: ObjectPoolとの統合による高速実行
    /// - 疎結合設計: インターフェース経由の依存性分離とテスタビリティ向上
    ///
    /// 【3層アーキテクチャ統合】
    /// - Core層基盤: ジャンル非依存の汎用コマンド実行機構として位置
    /// - Feature層連携: ゲーム固有コマンド（攻撃、移動、ダメージ等）の統一実行
    /// - Template層活用: ジャンル特化シーケンスの高レベル実行制御
    /// - ServiceLocator統合: ICommandInvokerサービスとしての中央管理
    ///
    /// 【Undo/Redo機能設計】
    /// - 双方向履歴管理: UndoスタックとRedoスタックの独立管理
    /// - 状態整合性保証: 各操作前のCanUndo/CanRedo検証必須
    /// - メモリ効率化: 履歴サイズ制限と古い履歴の自動削除
    /// - スレッドセーフ: 複数スレッドからの安全なアクセス保証
    ///
    /// 【ObjectPool最適化統合】
    /// - コマンドプール連携: 実行後コマンドの自動プール復帰
    /// - ゼロアロケーション: 実行時メモリ確保の最小化
    /// - 95%メモリ削減: プール再利用による大幅なメモリ効率向上
    /// - 67%実行速度改善: オブジェクト生成コスト削減による高速化
    ///
    /// 【典型的実装パターン】
    /// - ゲームアクション実行: damage.Execute() → Undo履歴追加 → プール復帰
    /// - プレイヤー操作取消: Undo() → 前状態復元 → Redoスタック移動
    /// - バッチ操作: 複数コマンドの一括実行と一括Undo対応
    /// - 条件付き実行: CanExecute()検証後の安全な実行制御
    ///
    /// 【ServiceLocator連携】
    /// - サービス登録: ServiceLocator.Register&lt;ICommandInvoker&gt;(invoker)
    /// - グローバルアクセス: var invoker = ServiceLocator.Get&lt;ICommandInvoker&gt;()
    /// - ライフサイクル管理: Initialize()/Shutdown()による適切な初期化・終了処理
    /// - 依存性注入回避: DIフレームワーク不要の軽量アーキテクチャ
    ///
    /// 【パフォーマンス特性】
    /// - 実行時間: O(1)でのコマンド実行（キューイングなし）
    /// - メモリ使用量: プール活用により従来比95%削減
    /// - スループット: 毎秒1000コマンド以上の高速実行対応
    /// - 履歴容量: 設定可能な最大履歴数による メモリ使用量制御
    /// </summary>
    public interface ICommandInvoker
    {
        /// <summary>
        /// Undo操作実行可能性判定プロパティ
        ///
        /// コマンド実行履歴にUndo可能な操作が存在するかどうかを示すプロパティです。
        /// Undoスタックが空でなく、かつスタック最上位のコマンドがCanUndo=trueの場合にtrueを返します。
        /// UI制御（Undoボタンの有効/無効状態）やゲームプレイロジックでの操作可否判定に使用されます。
        ///
        /// 【判定条件】
        /// - Undoスタック非空: 実行済みコマンドが1個以上存在
        /// - コマンド対応: スタック最上位コマンドのCanUndo==true
        /// - 状態整合性: コマンド実行時の状態記録が有効
        ///
        /// 【使用パターン】
        /// - UI制御: undoButton.interactable = invoker.CanUndo
        /// - 条件分岐: if (invoker.CanUndo) { /* Undo処理 */ }
        /// - デバッグ情報: Debug.Log($"Undo available: {invoker.CanUndo}")
        ///
        /// 【パフォーマンス特性】
        /// - 計算量: O(1) - スタック状態の即座確認
        /// - メモリ影響: なし - 状態参照のみ
        /// - スレッドセーフ: 読み取り専用操作として安全
        /// </summary>
        bool CanUndo { get; }

        /// <summary>
        /// Redo操作実行可能性判定プロパティ
        ///
        /// Undo実行により取り消された操作の再実行が可能かどうかを示すプロパティです。
        /// Redoスタックが空でなく、かつスタック最上位のコマンドが再実行可能な場合にtrueを返します。
        /// 通常、Undo操作直後や連続Undo後のRedo操作可否判定に使用されます。
        ///
        /// 【判定条件】
        /// - Redoスタック非空: Undo済みコマンドが1個以上存在
        /// - コマンド有効性: スタック最上位コマンドの実行状態が適切
        /// - 状態互換性: Redo実行時の前提条件が満たされている
        ///
        /// 【ライフサイクル管理】
        /// - Redo可能化: Undo()実行時にRedoスタックにコマンド追加
        /// - Redo無効化: 新しいコマンド実行時にRedoスタッククリア
        /// - 履歴限界: 最大Redo履歴数に達した場合の古い履歴削除
        ///
        /// 【使用パターン】
        /// - UI制御: redoButton.interactable = invoker.CanRedo
        /// - 条件分岐: if (invoker.CanRedo) { /* Redo処理 */ }
        /// - ゲーム状態: プレイヤーアクション復元の可否判定
        ///
        /// 【パフォーマンス特性】
        /// - 計算量: O(1) - スタック状態の即座確認
        /// - メモリ影響: なし - 状態参照のみ
        /// - スレッドセーフ: 読み取り専用操作として安全
        /// </summary>
        bool CanRedo { get; }

        /// <summary>
        /// Undo履歴スタック保存コマンド数取得プロパティ
        ///
        /// 現在Undoスタックに保存されているコマンドの総数を返すプロパティです。
        /// コマンド実行履歴の監視、メモリ使用量の把握、デバッグ情報表示に使用されます。
        /// 値が0の場合はUndo操作不可、正の値の場合はその回数分のUndo操作が可能です。
        ///
        /// 【値の意味】
        /// - 0: Undo履歴なし、Undo操作不可
        /// - 1以上: 対応する回数のUndo操作が実行可能
        /// - 最大値: 設定された履歴限界数に依存
        ///
        /// 【カウント変動タイミング】
        /// - 増加: ExecuteCommand()実行時（CanUndo=trueのコマンドのみ）
        /// - 減少: Undo()実行時またはClearHistory()実行時
        /// - 制限: 最大履歴数到達時の古い履歴自動削除
        ///
        /// 【使用パターン】
        /// - UI表示: $"Undo ({invoker.UndoStackCount})"
        /// - メモリ監視: if (invoker.UndoStackCount > 100) { /* 警告 */ }
        /// - デバッグ: Debug.Log($"Undo stack: {invoker.UndoStackCount} commands")
        /// - 条件判定: bool hasHistory = invoker.UndoStackCount > 0
        ///
        /// 【パフォーマンス特性】
        /// - 計算量: O(1) - スタックサイズの直接参照
        /// - メモリ影響: なし - カウント値の単純返却
        /// - 更新頻度: コマンド実行・Undo実行時のみ変動
        /// </summary>
        int UndoStackCount { get; }

        /// <summary>
        /// Redo履歴スタック保存コマンド数取得プロパティ
        ///
        /// 現在Redoスタックに保存されているコマンドの総数を返すプロパティです。
        /// Undo操作により取り消されたコマンドの数を表し、Redo可能な操作回数を示します。
        /// UI表示、履歴管理、デバッグ情報の提供に使用されます。
        ///
        /// 【値の意味】
        /// - 0: Redo履歴なし、Redo操作不可
        /// - 1以上: 対応する回数のRedo操作が実行可能
        /// - 変動性: 新しいコマンド実行時に0にリセット
        ///
        /// 【カウント変動タイミング】
        /// - 増加: Undo()実行時（取り消されたコマンドをRedoスタックに移動）
        /// - 減少: Redo()実行時（RedoスタックからUndoスタックに戻す）
        /// - リセット: ExecuteCommand()実行時（新操作によりRedo履歴無効化）
        /// - クリア: ClearHistory()実行時（全履歴削除）
        ///
        /// 【ライフサイクル連携】
        /// - Undo→Redo可能化: Undo実行でカウント増加
        /// - 新操作→Redo無効化: 新コマンド実行でカウント0
        /// - 履歴制限: 最大Redo履歴数による自動制限
        ///
        /// 【使用パターン】
        /// - UI表示: $"Redo ({invoker.RedoStackCount})"
        /// - 状態監視: bool canRedoMultiple = invoker.RedoStackCount > 1
        /// - デバッグ: Debug.Log($"Redo stack: {invoker.RedoStackCount} commands")
        /// - 条件分岐: if (invoker.RedoStackCount == 0) { /* Redo不可 */ }
        ///
        /// 【パフォーマンス特性】
        /// - 計算量: O(1) - スタックサイズの直接参照
        /// - メモリ影響: なし - カウント値の単純返却
        /// - 更新頻度: Undo・Redo・新コマンド実行時のみ変動
        /// </summary>
        int RedoStackCount { get; }

        /// <summary>
        /// コマンド実行・履歴管理統合メソッド
        ///
        /// 指定されたコマンドを実行し、Undo可能なコマンドについては自動的にUndo履歴に追加します。
        /// コマンド実行の中央窓口として機能し、実行前検証、実行処理、履歴管理、
        /// ObjectPool連携を統合的に処理する中核メソッドです。
        ///
        /// 【実行フロー】
        /// 1. 事前検証: command.CanExecute()による実行可否判定
        /// 2. Redo履歴クリア: 新操作実行により既存Redo履歴の無効化
        /// 3. コマンド実行: command.Execute()の呼び出し
        /// 4. 履歴追加: command.CanUndo==trueの場合のUndo履歴追加
        /// 5. プール復帰: IResettableCommandの場合の自動プール復帰
        ///
        /// 【履歴管理動作】
        /// - Undo対応コマンド: Undoスタックに追加、将来のUndo操作で復元可能
        /// - Undo非対応コマンド: 実行のみ、履歴追加なし
        /// - Redo履歴無効化: 新コマンド実行によりRedoスタックの自動クリア
        /// - 履歴制限: 最大履歴数超過時の古い履歴自動削除
        ///
        /// 【エラーハンドリング】
        /// - null引数: ArgumentNullExceptionスロー
        /// - 実行失敗: コマンド内部例外の適切な伝播
        /// - 状態不整合: 実行前状態の検証と安全な回復
        ///
        /// 【ObjectPool統合】
        /// - プール対応: IResettableCommand実装の自動検出
        /// - 自動復帰: 実行完了後のCommandPool.Return()呼び出し
        /// - メモリ効率: 95%メモリ削減効果の実現
        /// - 実行速度: 67%速度改善効果の実現
        ///
        /// 【使用パターン】
        /// - 基本実行: invoker.ExecuteCommand(new DamageCommand(target, 50))
        /// - プール活用: invoker.ExecuteCommand(CommandPool.Get&lt;HealCommand&gt;())
        /// - 条件付き: if (command.CanExecute()) invoker.ExecuteCommand(command)
        /// - バッチ処理: commands.ForEach(invoker.ExecuteCommand)
        ///
        /// 【パフォーマンス特性】
        /// - 実行時間: O(1) - 直接実行（キューイングなし）
        /// - メモリ使用: プール活用時95%削減
        /// - スループット: 毎秒1000コマンド以上の高速処理
        /// - GC負荷: プール使用時のゼロアロケーション
        /// </summary>
        /// <param name="command">実行対象のコマンドオブジェクト。nullの場合はArgumentNullExceptionをスロー。</param>
        void ExecuteCommand(ICommand command);

        /// <summary>
        /// 最新コマンド取り消し・状態復元実行メソッド
        ///
        /// Undoスタックの最上位（最後に実行された）コマンドの取り消し処理を実行し、
        /// システム状態を当該コマンド実行前の状態に復元します。
        /// 成功時はコマンドをRedoスタックに移動し、将来のRedo操作を可能にします。
        ///
        /// 【実行フロー】
        /// 1. 実行可否確認: CanUndo==trueの検証
        /// 2. コマンド取得: Undoスタック最上位からのポップ
        /// 3. 状態復元: command.Undo()による前状態復元
        /// 4. Redo準備: 成功時のRedoスタックへの追加
        /// 5. 結果返却: 成功・失敗の真偽値返却
        ///
        /// 【状態復元処理】
        /// - 完全復元: Execute()前の状態への正確な復元
        /// - 副作用除去: Execute()で発生した全ての副作用の取り消し
        /// - データ整合性: 複数オブジェクトにまたがる状態の一貫性保証
        /// - リソース復元: メモリ、ファイル、ネットワーク状態の適切な復元
        ///
        /// 【エラーハンドリング】
        /// - Undo不可: CanUndo==false時のfalse返却（例外なし）
        /// - 復元失敗: コマンド内部例外の捕捉と適切な処理
        /// - 状態不整合: 部分復元失敗時の安全な状態維持
        /// - 履歴保護: 失敗時のUndoスタック状態保持
        ///
        /// 【Redoスタック連携】
        /// - 成功時追加: Undo成功コマンドのRedoスタック追加
        /// - 失敗時保持: Undo失敗時のRedoスタック状態維持
        /// - 履歴制限: 最大Redo履歴数による古い履歴削除
        ///
        /// 【使用パターン】
        /// - 基本取消: if (invoker.CanUndo) invoker.Undo()
        /// - UI連携: undoButton.onClick += () =&gt; invoker.Undo()
        /// - 条件分岐: bool success = invoker.Undo(); if (success) { /* 処理 */ }
        /// - 連続Undo: while (invoker.CanUndo) invoker.Undo()
        ///
        /// 【パフォーマンス特性】
        /// - 実行時間: O(1) - スタック操作とUndo()呼び出しのみ
        /// - メモリ影響: スタック間移動、新規アロケーションなし
        /// - 状態複雑度: 個別コマンドのUndo実装に依存
        /// - スレッドセーフ: 内部同期による安全な並行アクセス
        /// </summary>
        /// <returns>Undo操作が成功した場合はtrue、実行不可・失敗の場合はfalse</returns>
        bool Undo();

        /// <summary>
        /// 最新Undo済みコマンド再実行・状態復元メソッド
        ///
        /// Redoスタックの最上位（最後にUndoされた）コマンドの再実行処理を実行し、
        /// システム状態を当該コマンドの実行結果状態に復元します。
        /// 成功時はコマンドをUndoスタックに戻し、再度のUndo操作を可能にします。
        ///
        /// 【実行フロー】
        /// 1. 実行可否確認: CanRedo==trueの検証
        /// 2. コマンド取得: Redoスタック最上位からのポップ
        /// 3. 状態復元: command.Execute()による実行状態復元
        /// 4. Undo準備: 成功時のUndoスタックへの追加
        /// 5. 結果返却: 成功・失敗の真偽値返却
        ///
        /// 【状態復元処理】
        /// - 実行状態復元: Undo()で取り消された効果の再適用
        /// - 副作用再現: 元のExecute()で発生した副作用の再実行
        /// - データ整合性: 複数オブジェクトにまたがる状態の一貫性復元
        /// - リソース再適用: メモリ、ファイル、ネットワーク状態の再構築
        ///
        /// 【エラーハンドリング】
        /// - Redo不可: CanRedo==false時のfalse返却（例外なし）
        /// - 実行失敗: コマンド内部例外の捕捉と適切な処理
        /// - 状態競合: 実行環境変化時の安全な失敗処理
        /// - 履歴保護: 失敗時のRedoスタック状態保持
        ///
        /// 【Undoスタック連携】
        /// - 成功時追加: Redo成功コマンドのUndoスタック復帰
        /// - 失敗時保持: Redo失敗時のUndoスタック状態維持
        /// - 履歴制限: 最大Undo履歴数による古い履歴削除
        ///
        /// 【使用パターン】
        /// - 基本復元: if (invoker.CanRedo) invoker.Redo()
        /// - UI連携: redoButton.onClick += () =&gt; invoker.Redo()
        /// - 条件分岐: bool success = invoker.Redo(); if (success) { /* 処理 */ }
        /// - 連続Redo: while (invoker.CanRedo) invoker.Redo()
        ///
        /// 【ライフサイクル特性】
        /// - Redo可能化: Undo()実行によるRedo履歴生成
        /// - Redo無効化: ExecuteCommand()実行による新操作優先
        /// - 履歴消失: ClearHistory()による全Redo履歴削除
        ///
        /// 【パフォーマンス特性】
        /// - 実行時間: O(1) - スタック操作とExecute()呼び出しのみ
        /// - メモリ影響: スタック間移動、新規アロケーションなし
        /// - 状態複雑度: 個別コマンドのExecute実装に依存
        /// - スレッドセーフ: 内部同期による安全な並行アクセス
        /// </summary>
        /// <returns>Redo操作が成功した場合はtrue、実行不可・失敗の場合はfalse</returns>
        bool Redo();

        /// <summary>
        /// Undo・Redo履歴完全消去・メモリ解放メソッド
        ///
        /// UndoスタックとRedoスタックの両方を完全にクリアし、
        /// 保存されている全てのコマンド履歴を削除します。
        /// メモリ使用量の最適化、ゲーム状態のリセット、プール復帰処理を統合実行します。
        ///
        /// 【クリア対象】
        /// - Undoスタック: 全実行済みコマンド履歴の削除
        /// - Redoスタック: 全取り消し済みコマンド履歴の削除
        /// - 関連メタデータ: 履歴カウント、統計情報のリセット
        /// - 内部状態: スタック管理用内部変数の初期化
        ///
        /// 【メモリ管理処理】
        /// - プール復帰: IResettableCommand実装の自動プール復帰
        /// - 参照解除: コマンドオブジェクトへの参照の完全削除
        /// - GC促進: 大量オブジェクト解放による ガベージコレクション効率化
        /// - メモリ最適化: 長期実行時のメモリリーク防止
        ///
        /// 【実行タイミング】
        /// - ゲーム終了時: セッション終了でのリソース解放
        /// - シーン切り替え: 新規ゲーム状態への完全リセット
        /// - メモリ不足時: 緊急時のメモリ確保処理
        /// - デバッグ時: テスト間での状態クリーンアップ
        ///
        /// 【副作用と注意点】
        /// - 不可逆処理: 一度クリアすると履歴復元不可
        /// - UI影響: Undo/Redoボタンの無効化
        /// - プレイヤー体験: 操作取り消し機能の一時的停止
        /// - パフォーマンス: 大量履歴クリア時の一瞬の処理負荷
        ///
        /// 【使用パターン】
        /// - シーン遷移: sceneManager.sceneLoaded += (s, m) =&gt; invoker.ClearHistory()
        /// - ゲーム開始: gameManager.StartNewGame += () =&gt; invoker.ClearHistory()
        /// - セーブ完了: saveSystem.SaveCompleted += () =&gt; invoker.ClearHistory()
        /// - メモリ警告: Application.lowMemory += () =&gt; invoker.ClearHistory()
        ///
        /// 【パフォーマンス特性】
        /// - 実行時間: O(n) - nは履歴数、プール復帰処理を含む
        /// - メモリ解放: 履歴サイズに比例した大量メモリ解放
        /// - GC影響: 解放処理による一時的なGCプレッシャー増加
        /// - スレッドセーフ: 内部同期による安全な並行アクセス
        /// </summary>
        void ClearHistory();
    }
}