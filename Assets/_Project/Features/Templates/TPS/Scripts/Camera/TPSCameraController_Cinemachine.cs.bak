using UnityEngine;
using asterivo.Unity60.Core.Events;
using asterivo.Unity60.Features.Templates.TPS.Player;
using Cinemachine;
using Sirenix.OdinInspector;

namespace asterivo.Unity60.Features.Templates.TPS.Camera
{
    /// <summary>
    /// TPS専用カメラ制御システム
    /// 三人称視点カメラ制御システムにCinemachine 3.1を統合
    /// カメラコリジョン回避、エイム時の肩越し視点切り替え、カバー時の視点調整を実装
    /// プレイヤー追従システム（距離・角度調整）とスムーズな視点遷移を提供
    /// </summary>
    public class TPSCameraController : MonoBehaviour
    {
        [TabGroup("TPS Camera", "Camera Settings")]
        [BoxGroup("TPS Camera/Camera Settings/Follow Settings")]
        [LabelText("Follow Distance")]
        [PropertyRange(2f, 10f)]
        [SerializeField] private float followDistance = 5f;

        [BoxGroup("TPS Camera/Camera Settings/Follow Settings")]
        [LabelText("Follow Height")]
        [PropertyRange(0.5f, 3f)]
        [SerializeField] private float followHeight = 1.8f;

        [BoxGroup("TPS Camera/Camera Settings/Follow Settings")]
        [LabelText("Follow Smoothness")]
        [PropertyRange(1f, 15f)]
        [SerializeField] private float followSmoothness = 8f;

        [BoxGroup("TPS Camera/Camera Settings/Look Settings")]
        [LabelText("Look Sensitivity")]
        [PropertyRange(50f, 300f)]
        [SerializeField] private float lookSensitivity = 120f;

        [BoxGroup("TPS Camera/Camera Settings/Look Settings")]
        [LabelText("Vertical Look Limit")]
        [PropertyRange(30f, 90f)]
        [SerializeField] private float verticalLookLimit = 80f;

        [BoxGroup("TPS Camera/Camera Settings/Look Settings")]
        [LabelText("Look Smoothness")]
        [PropertyRange(1f, 15f)]
        [SerializeField] private float lookSmoothness = 10f;

        [TabGroup("TPS Camera", "Aiming")]
        [BoxGroup("TPS Camera/Aiming/Aim Settings")]
        [LabelText("Aim Distance")]
        [PropertyRange(1f, 4f)]
        [SerializeField] private float aimDistance = 2.5f;

        [BoxGroup("TPS Camera/Aiming/Aim Settings")]
        [LabelText("Aim Height Offset")]
        [PropertyRange(-0.5f, 0.5f)]
        [SerializeField] private float aimHeightOffset = 0.2f;

        [BoxGroup("TPS Camera/Aiming/Aim Settings")]
        [LabelText("Aim Side Offset")]
        [PropertyRange(0.3f, 1.5f)]
        [SerializeField] private float aimSideOffset = 0.8f;

        [BoxGroup("TPS Camera/Aiming/Transition")]
        [LabelText("Aim Transition Speed")]
        [PropertyRange(2f, 15f)]
        [SerializeField] private float aimTransitionSpeed = 8f;

        [BoxGroup("TPS Camera/Aiming/Transition")]
        [LabelText("FOV Normal")]
        [PropertyRange(40f, 80f)]
        [SerializeField] private float fovNormal = 60f;

        [BoxGroup("TPS Camera/Aiming/Transition")]
        [LabelText("FOV Aim")]
        [PropertyRange(20f, 50f)]
        [SerializeField] private float fovAim = 40f;

        [TabGroup("TPS Camera", "Cover System")]
        [BoxGroup("TPS Camera/Cover System/Cover Settings")]
        [LabelText("Cover Distance")]
        [PropertyRange(1f, 5f)]
        [SerializeField] private float coverDistance = 3f;

        [BoxGroup("TPS Camera/Cover System/Cover Settings")]
        [LabelText("Cover Height Offset")]
        [PropertyRange(-0.5f, 1f)]
        [SerializeField] private float coverHeightOffset = 0.3f;

        [BoxGroup("TPS Camera/Cover System/Cover Settings")]
        [LabelText("Cover Side Offset")]
        [PropertyRange(0.5f, 2f)]
        [SerializeField] private float coverSideOffset = 1.2f;

        [TabGroup("TPS Camera", "Collision")]
        [BoxGroup("TPS Camera/Collision/Collision Settings")]
        [LabelText("Collision Layer Mask")]
        [SerializeField] private LayerMask collisionLayerMask = 1;

        [BoxGroup("TPS Camera/Collision/Collision Settings")]
        [LabelText("Collision Buffer")]
        [PropertyRange(0.1f, 1f)]
        [SerializeField] private float collisionBuffer = 0.3f;

        [BoxGroup("TPS Camera/Collision/Collision Settings")]
        [LabelText("Collision Smoothness")]
        [PropertyRange(2f, 20f)]
        [SerializeField] private float collisionSmoothness = 12f;

        [TabGroup("TPS Camera", "Cinemachine")]
        [BoxGroup("TPS Camera/Cinemachine/Virtual Cameras")]
        [LabelText("Normal Camera")]
        [SerializeField] private CinemachineVirtualCamera normalCamera;

        [BoxGroup("TPS Camera/Cinemachine/Virtual Cameras")]
        [LabelText("Aim Camera")]
        [SerializeField] private CinemachineVirtualCamera aimCamera;

        [BoxGroup("TPS Camera/Cinemachine/Virtual Cameras")]
        [LabelText("Cover Camera")]
        [SerializeField] private CinemachineVirtualCamera coverCamera;

        [TabGroup("Events", "Camera Events")]
        [LabelText("On Camera Mode Changed")]
        [SerializeField] private GameEvent onCameraModeChanged;

        [LabelText("On Aim Mode Started")]
        [SerializeField] private GameEvent onAimModeStarted;

        [LabelText("On Aim Mode Stopped")]
        [SerializeField] private GameEvent onAimModeStopped;

        // Private components and variables
        private Transform targetPlayer;
        private TPSPlayerController playerController;
        private UnityEngine.Camera mainCamera;
        
        // Camera state
        private CameraMode currentMode = CameraMode.Normal;
        private bool isAiming = false;
        private bool isInCover = false;
        
        // Look input and rotation
        private Vector2 lookInput;
        private float currentVerticalRotation = 0f;
        private float currentHorizontalRotation = 0f;
        
        // Position calculation
        private Vector3 desiredPosition;
        private Vector3 currentVelocity;
        
        // Collision detection
        private float currentDistance;
        private bool hasCollision = false;

        public enum CameraMode
        {
            Normal,
            Aiming,
            Cover
        }

        [TabGroup("Debug", "Camera State")]
        [ReadOnly]
        [ShowInInspector]
        [LabelText("Current Mode")]
        private CameraMode debugCurrentMode => currentMode;

        [ReadOnly]
        [ShowInInspector]
        [LabelText("Is Aiming")]
        private bool debugIsAiming => isAiming;

        [ReadOnly]
        [ShowInInspector]
        [LabelText("Is In Cover")]
        private bool debugIsInCover => isInCover;

        [ReadOnly]
        [ShowInInspector]
        [LabelText("Current Distance")]
        private float debugCurrentDistance => currentDistance;

        [ReadOnly]
        [ShowInInspector]
        [LabelText("Has Collision")]
        private bool debugHasCollision => hasCollision;

        private void Awake()
        {
            mainCamera = UnityEngine.Camera.main;
            if (mainCamera == null)
            {
                mainCamera = FindFirstObjectByType<UnityEngine.Camera>();
            }
            
            currentDistance = followDistance;
        }

        private void Start()
        {
            SetupCinemachineCameras();
        }

        private void Update()
        {
            if (targetPlayer == null) return;

            HandleInput();
            UpdateCameraMode();
            HandleCameraCollision();
        }

        private void LateUpdate()
        {
            if (targetPlayer == null) return;

            UpdateCameraPosition();
            UpdateCameraRotation();
        }

        private void HandleInput()
        {
            // Mouse look input (using Input System in actual implementation)
            lookInput.x = Input.GetAxis("Mouse X") * lookSensitivity * Time.deltaTime;
            lookInput.y = Input.GetAxis("Mouse Y") * lookSensitivity * Time.deltaTime;

            // Update rotation values
            currentHorizontalRotation += lookInput.x;
            currentVerticalRotation -= lookInput.y;
            currentVerticalRotation = Mathf.Clamp(currentVerticalRotation, -verticalLookLimit, verticalLookLimit);
        }

        private void UpdateCameraMode()
        {
            if (playerController == null) return;

            CameraMode newMode = CameraMode.Normal;

            if (playerController.IsInCover)
            {
                newMode = CameraMode.Cover;
                isInCover = true;
            }
            else if (playerController.IsAiming)
            {
                newMode = CameraMode.Aiming;
                isInCover = false;
            }
            else
            {
                newMode = CameraMode.Normal;
                isInCover = false;
            }

            if (newMode != currentMode)
            {
                SetCameraMode(newMode);
            }
        }

        private void SetCameraMode(CameraMode newMode)
        {
            currentMode = newMode;
            
            // Switch Cinemachine cameras
            SetCinemachineCameraPriority(newMode);
            
            // Update FOV
            UpdateFieldOfView(newMode);
            
            // Notify other systems
            onCameraModeChanged?.Raise();
            
            UnityEngine.Debug.Log("[TPS] Camera mode changed to: " + newMode);
        }

        private void SetCinemachineCameraPriority(CameraMode mode)
        {
            // Reset all camera priorities
            if (normalCamera != null) normalCamera.Priority = 10;
            if (aimCamera != null) aimCamera.Priority = 10;
            if (coverCamera != null) coverCamera.Priority = 10;

            // Set active camera priority higher
            switch (mode)
            {
                case CameraMode.Normal:
                    if (normalCamera != null) normalCamera.Priority = 20;
                    break;
                case CameraMode.Aiming:
                    if (aimCamera != null) aimCamera.Priority = 20;
                    break;
                case CameraMode.Cover:
                    if (coverCamera != null) coverCamera.Priority = 20;
                    break;
            }
        }

        private void UpdateFieldOfView(CameraMode mode)
        {
            float targetFOV = mode == CameraMode.Aiming ? fovAim : fovNormal;
            
            if (mainCamera != null)
            {
                mainCamera.fieldOfView = Mathf.Lerp(mainCamera.fieldOfView, targetFOV, Time.deltaTime * aimTransitionSpeed);
            }

            // Update Cinemachine cameras FOV
            UpdateCinemachineFOV(targetFOV);
        }

        private void UpdateCinemachineFOV(float targetFOV)
        {
            if (normalCamera != null)
                normalCamera.m_Lens.FieldOfView = targetFOV;
            
            if (aimCamera != null)
                aimCamera.m_Lens.FieldOfView = targetFOV;
            
            if (coverCamera != null)
                coverCamera.m_Lens.FieldOfView = targetFOV;
        }

        private void HandleCameraCollision()
        {
            if (targetPlayer == null) return;

            Vector3 rayDirection = (transform.position - targetPlayer.position).normalized;
            RaycastHit hit;
            
            float checkDistance = GetCurrentTargetDistance();
            
            if (Physics.Raycast(targetPlayer.position, rayDirection, out hit, checkDistance, collisionLayerMask))
            {
                hasCollision = true;
                float collisionDistance = Vector3.Distance(targetPlayer.position, hit.point) - collisionBuffer;
                currentDistance = Mathf.Lerp(currentDistance, Mathf.Max(collisionDistance, 1f), Time.deltaTime * collisionSmoothness);
            }
            else
            {
                hasCollision = false;
                currentDistance = Mathf.Lerp(currentDistance, GetCurrentTargetDistance(), Time.deltaTime * collisionSmoothness);
            }
        }

        private float GetCurrentTargetDistance()
        {
            switch (currentMode)
            {
                case CameraMode.Aiming:
                    return aimDistance;
                case CameraMode.Cover:
                    return coverDistance;
                default:
                    return followDistance;
            }
        }

        private void UpdateCameraPosition()
        {
            Vector3 targetPosition = CalculateTargetPosition();
            
            // Smooth position transition
            transform.position = Vector3.SmoothDamp(transform.position, targetPosition, ref currentVelocity, 1f / followSmoothness);
        }

        private Vector3 CalculateTargetPosition()
        {
            Vector3 basePosition = targetPlayer.position;
            
            switch (currentMode)
            {
                case CameraMode.Aiming:
                    return CalculateAimPosition(basePosition);
                case CameraMode.Cover:
                    return CalculateCoverPosition(basePosition);
                default:
                    return CalculateNormalPosition(basePosition);
            }
        }

        private Vector3 CalculateNormalPosition(Vector3 basePosition)
        {
            // Standard third-person position
            Vector3 offset = Quaternion.Euler(currentVerticalRotation, currentHorizontalRotation, 0) * Vector3.back * currentDistance;
            Vector3 heightOffset = Vector3.up * followHeight;
            
            return basePosition + heightOffset + offset;
        }

        private Vector3 CalculateAimPosition(Vector3 basePosition)
        {
            // Over-the-shoulder aiming position
            Vector3 offset = Quaternion.Euler(currentVerticalRotation, currentHorizontalRotation, 0) * Vector3.back * currentDistance;
            Vector3 heightOffset = Vector3.up * (followHeight + aimHeightOffset);
            Vector3 sideOffset = Quaternion.Euler(0, currentHorizontalRotation, 0) * Vector3.right * aimSideOffset;
            
            return basePosition + heightOffset + offset + sideOffset;
        }

        private Vector3 CalculateCoverPosition(Vector3 basePosition)
        {
            // Cover position with side offset for peeking
            Vector3 offset = Quaternion.Euler(currentVerticalRotation, currentHorizontalRotation, 0) * Vector3.back * currentDistance;
            Vector3 heightOffset = Vector3.up * (followHeight + coverHeightOffset);
            Vector3 sideOffset = Quaternion.Euler(0, currentHorizontalRotation, 0) * Vector3.right * coverSideOffset;
            
            return basePosition + heightOffset + offset + sideOffset;
        }

        private void UpdateCameraRotation()
        {
            // Smooth rotation transition
            Quaternion targetRotation = Quaternion.Euler(currentVerticalRotation, currentHorizontalRotation, 0);
            transform.rotation = Quaternion.Slerp(transform.rotation, targetRotation, Time.deltaTime * lookSmoothness);
        }

        private void SetupCinemachineCameras()
        {
            // Auto-find Cinemachine cameras if not assigned
            if (normalCamera == null)
            {
                normalCamera = FindCinemachineCamera("TPS_Normal_Camera");
            }
            
            if (aimCamera == null)
            {
                aimCamera = FindCinemachineCamera("TPS_Aim_Camera");
            }
            
            if (coverCamera == null)
            {
                coverCamera = FindCinemachineCamera("TPS_Cover_Camera");
            }

            // Setup camera follow targets
            if (targetPlayer != null)
            {
                SetupCameraFollow();
            }
        }

        private CinemachineVirtualCamera FindCinemachineCamera(string cameraName)
        {
            GameObject cameraObj = GameObject.Find(cameraName);
            if (cameraObj != null)
            {
                return cameraObj.GetComponent<CinemachineVirtualCamera>();
            }
            return null;
        }

        private void SetupCameraFollow()
        {
            if (normalCamera != null)
            {
                normalCamera.Follow = targetPlayer;
                normalCamera.LookAt = targetPlayer;
            }
            
            if (aimCamera != null)
            {
                aimCamera.Follow = targetPlayer;
                aimCamera.LookAt = targetPlayer;
            }
            
            if (coverCamera != null)
            {
                coverCamera.Follow = targetPlayer;
                coverCamera.LookAt = targetPlayer;
            }
        }

        // Public methods for external control
        public void Initialize(Transform player)
        {
            targetPlayer = player;
            playerController = player.GetComponent<TPSPlayerController>();
            
            if (playerController == null)
            {
                UnityEngine.Debug.LogWarning("[TPS] TPSPlayerController not found on target player");
            }
            
            SetupCinemachineCameras();
            
            UnityEngine.Debug.Log("[TPS] TPSCameraController initialized");
        }

        public void SetAimingMode(bool aiming)
        {
            isAiming = aiming;
            
            if (aiming)
            {
                onAimModeStarted?.Raise();
            }
            else
            {
                onAimModeStopped?.Raise();
            }
        }

        public void SetSensitivity(float sensitivity)
        {
            lookSensitivity = sensitivity;
        }

        public void SetFollowDistance(float distance)
        {
            followDistance = Mathf.Clamp(distance, 2f, 10f);
        }

        // Property accessors
        public CameraMode CurrentMode => currentMode;
        public bool IsAiming => isAiming;
        public bool IsInCover => isInCover;
        public Vector3 CameraForward => transform.forward;
        public Vector3 CameraRight => transform.right;

        // Gizmos for visualization
        private void OnDrawGizmosSelected()
        {
            if (targetPlayer == null) return;

            // Draw camera position
            Gizmos.color = Color.cyan;
            Gizmos.DrawSphere(transform.position, 0.2f);

            // Draw follow distance
            Gizmos.color = Color.blue;
            Gizmos.DrawWireSphere(targetPlayer.position, followDistance);

            // Draw aim distance
            Gizmos.color = Color.green;
            Gizmos.DrawWireSphere(targetPlayer.position, aimDistance);

            // Draw cover distance
            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(targetPlayer.position, coverDistance);

            // Draw collision ray
            if (hasCollision)
            {
                Gizmos.color = Color.yellow;
                Gizmos.DrawRay(targetPlayer.position, (transform.position - targetPlayer.position).normalized * currentDistance);
            }
        }
    }
}